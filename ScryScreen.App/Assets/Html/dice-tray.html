<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScryScreen Dice Tray</title>
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#0A0F18; }
    #c { display:block; width:100%; height:100%; }
    .hint { position:absolute; left:10px; top:8px; color:#94a3b8; font: 12px/1.2 system-ui, Segoe UI, sans-serif; opacity:0.85; user-select:none; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Click a die: d4 d6 d8 d10 d12 d20</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setClearColor(0x0A0F18, 1);
    renderer.physicallyCorrectLights = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.12;

    const scene = new THREE.Scene();

    // Subtle reflections for all dice (no external assets/imports).
    // We generate a tiny equirectangular "room" gradient, then PMREM it.
    (function setupEnvironment() {
      const w = 64;
      const h = 32;
      const data = new Uint8Array(w * h * 4);

      // Top->bottom gradient: deep blue -> slate -> near-black
      const top = { r: 16, g: 30, b: 56 };
      const mid = { r: 58, g: 66, b: 84 };
      const bot = { r: 6, g: 10, b: 18 };

      for (let y = 0; y < h; y++) {
        const t = y / (h - 1);
        const t2 = Math.min(1, Math.max(0, (t - 0.40) / 0.60));
        const r = Math.round(top.r * (1 - t) + mid.r * t);
        const g = Math.round(top.g * (1 - t) + mid.g * t);
        const b = Math.round(top.b * (1 - t) + mid.b * t);
        const rr = Math.round(r * (1 - t2) + bot.r * t2);
        const gg = Math.round(g * (1 - t2) + bot.g * t2);
        const bb = Math.round(b * (1 - t2) + bot.b * t2);

        for (let x = 0; x < w; x++) {
          // Add a subtle bright "softbox" patch near the top-center so reflections read
          // on flat faces (e.g., d6) as well as many-faced dice (e.g., d10).
          const xn = x / (w - 1);
          const yn = y / (h - 1);
          const cx = 0.5;
          const cy = 0.14;
          const dx = (xn - cx) / 0.35;
          const dy = (yn - cy) / 0.10;
          const softbox = Math.exp(-(dx * dx + dy * dy));
          const boost = 0.55 * softbox;

          const r2 = Math.min(255, Math.round(rr + (255 - rr) * boost));
          const g2 = Math.min(255, Math.round(gg + (255 - gg) * boost));
          const b2 = Math.min(255, Math.round(bb + (255 - bb) * boost));

          const i = (y * w + x) * 4;
          data[i + 0] = r2;
          data[i + 1] = g2;
          data[i + 2] = b2;
          data[i + 3] = 255;
        }
      }

      const tex = new THREE.DataTexture(data, w, h, THREE.RGBAFormat);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.mapping = THREE.EquirectangularReflectionMapping;
      tex.needsUpdate = true;

      const pmrem = new THREE.PMREMGenerator(renderer);
      // IMPORTANT: keep the render target alive; disposing it also disposes the texture.
      const envRT = pmrem.fromEquirectangular(tex);
      scene.environment = envRT.texture;
      tex.dispose();

      // Optional cleanup on page unload.
      window.addEventListener('unload', () => {
        try { envRT.dispose(); } catch { }
        try { pmrem.dispose(); } catch { }
      });
    })();

    // Camera is framed so dice live near the *top* of the view.
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 60);
    camera.position.set(0, 6.0, 11.0);
    camera.lookAt(0, 2.5, 0);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x111827, 0.9);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.3);
    dir.position.set(5, 7, 6);
    scene.add(dir);

    // Add a focused light to create a readable specular highlight on ALL dice.
    // This helps flat-faced dice (like d6) show the same "reflection" as d10.
    const spot = new THREE.SpotLight(0xffffff, 85, 0, Math.PI / 10, 0.25, 1.0);
    spot.position.set(-3.5, 10, 7.5);
    spot.target.position.set(0, 2.1, 0);
    spot.castShadow = false;
    scene.add(spot);
    scene.add(spot.target);

    const floorGeo = new THREE.PlaneGeometry(30, 14);
    const floorMat = new THREE.ShadowMaterial({ opacity: 0.25 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0.0;
    floor.receiveShadow = true;
    scene.add(floor);

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const metal = 0.55;
    const rough = 0.08;
    const baseMat = new THREE.MeshPhysicalMaterial({
      color: 0xf3f4f6,
      metalness: metal,
      roughness: rough,
      envMapIntensity: 2.75,
      clearcoat: 1.0,
      clearcoatRoughness: 0.06,
      ior: 1.5,
      flatShading: true,
    });

    function makeEdges(mesh) {
      const eg = new THREE.EdgesGeometry(mesh.geometry, 25);
      const lm = new THREE.LineBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.8 });
      const lines = new THREE.LineSegments(eg, lm);
      lines.position.copy(mesh.position);
      lines.quaternion.copy(mesh.quaternion);
      lines.scale.copy(mesh.scale);
      return lines;
    }

    function ensureOutwardWinding(geometry) {
      // Fixes triangle winding so faces render with FrontSide materials.
      // For convex polyhedra centered at origin, outward normals satisfy normal·centroid > 0.
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      if (!pos || !index) return;

      const a = new THREE.Vector3();
      const b = new THREE.Vector3();
      const c = new THREE.Vector3();
      const ab = new THREE.Vector3();
      const ac = new THREE.Vector3();
      const n = new THREE.Vector3();
      const centroid = new THREE.Vector3();

      for (let i = 0; i < index.count; i += 3) {
        const ia = index.getX(i);
        const ib = index.getX(i + 1);
        const ic = index.getX(i + 2);
        a.fromBufferAttribute(pos, ia);
        b.fromBufferAttribute(pos, ib);
        c.fromBufferAttribute(pos, ic);

        ab.copy(b).sub(a);
        ac.copy(c).sub(a);
        n.copy(ab).cross(ac);
        centroid.copy(a).add(b).add(c).multiplyScalar(1 / 3);

        if (n.dot(centroid) < 0) {
          // Swap winding
          index.setX(i + 1, ic);
          index.setX(i + 2, ib);
        }
      }

      index.needsUpdate = true;
    }

    // D10: pentagonal trapezohedron built as indexed triangles.
    // Important: the two triangles that make each kite must be coplanar, otherwise
    // EdgesGeometry will show the diagonal and the shape looks "broken".
    function createD10Geometry(radius = 0.86) {
      const n = 5;

      // Planarity constraint for this construction: apexDistance / ringPlaneOffset ≈ 9.472135955
      const apexToPlane = 9.47213595499958;

      const apexY = radius * 0.90;
      const ringY = apexY / apexToPlane;
      const r = radius * 0.82;

      // Vertex layout (Y-up):
      // 0 = top apex, 1 = bottom apex, 2..6 = U0..U4, 7..11 = L0..L4
      const verts = [];
      verts.push([0, +apexY, 0]);
      verts.push([0, -apexY, 0]);

      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * k) / n;
        verts.push([Math.cos(a) * r, +ringY, Math.sin(a) * r]);
      }
      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * (k + 0.5)) / n;
        verts.push([Math.cos(a) * r, -ringY, Math.sin(a) * r]);
      }

      const idx = [];
      const T = 0;
      const B = 1;
      const U0 = 2;
      const L0 = 7;

      // Each kite face is split into two triangles.
      // Top kites: [T, U_k, L_k, U_{k+1}]
      for (let k = 0; k < n; k++) {
        const Uk = U0 + k;
        const Uk1 = U0 + ((k + 1) % n);
        const Lk = L0 + k;
        idx.push(T, Uk, Lk);
        idx.push(T, Lk, Uk1);
      }
      // Bottom kites: [B, L_k, U_{k+1}, L_{k+1}]
      for (let k = 0; k < n; k++) {
        const Lk = L0 + k;
        const Lk1 = L0 + ((k + 1) % n);
        const Uk1 = U0 + ((k + 1) % n);
        idx.push(B, Lk, Uk1);
        idx.push(B, Uk1, Lk1);
      }

      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts.flat()), 3));
      g.setIndex(idx);
      ensureOutwardWinding(g);
      g.computeVertexNormals();
      g.computeBoundingBox();
      g.computeBoundingSphere();
      return g;
    }

    function createFaceLabelTexture(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.font = 'bold 120px system-ui, Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Outline for contrast.
      ctx.lineWidth = 10;
      ctx.strokeStyle = 'rgba(255,255,255,0.75)';
      ctx.strokeText(String(text), 128, 128);
      ctx.fillStyle = 'rgba(17,24,39,0.92)';
      ctx.fillText(String(text), 128, 128);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      tex.needsUpdate = true;
      return { canvas, ctx, tex };
    }

    function createFaceLabelPlane(text, scale = 0.45) {
      const plate = createFaceLabelTexture(text);
      const mat = new THREE.MeshBasicMaterial({
        map: plate.tex,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        side: THREE.DoubleSide,
        // Keep the label visually "printed" on the face without needing a large offset.
        polygonOffset: true,
        polygonOffsetFactor: -2,
        polygonOffsetUnits: -2,
      });
      const geo = new THREE.PlaneGeometry(scale, scale);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData._label = plate;
      return mesh;
    }

    function computeFaceGroups(geometry) {
      // Returns array of { normal, center, triangles:[{ia,ib,ic}] } for coplanar face groups.
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      if (!pos) return [];

      const epsDot = 0.9995;
      const epsD = 1e-3;
      const groups = [];

      const a = new THREE.Vector3();
      const b = new THREE.Vector3();
      const c = new THREE.Vector3();
      const n = new THREE.Vector3();
      const tmp = new THREE.Vector3();

      const triCount = index ? index.count : pos.count;
      for (let i = 0; i < triCount; i += 3) {
        const ia = index ? index.getX(i) : i;
        const ib = index ? index.getX(i + 1) : (i + 1);
        const ic = index ? index.getX(i + 2) : (i + 2);
        a.fromBufferAttribute(pos, ia);
        b.fromBufferAttribute(pos, ib);
        c.fromBufferAttribute(pos, ic);

        n.copy(b).sub(a).cross(tmp.copy(c).sub(a)).normalize();
        if (!Number.isFinite(n.x)) continue;
        let d = -n.dot(a);

        let found = null;
        for (const g of groups) {
          const dot = g.normal.dot(n);
          if (Math.abs(dot) <= epsDot) continue;

          if (dot > 0) {
            // Same normal direction -> same plane means d matches.
            if (Math.abs(g.d - d) < epsD) {
              found = g;
              break;
            }
          } else {
            // Opposite normal direction -> same plane means d is negated.
            if (Math.abs(g.d + d) < epsD) {
              // Align to group orientation for consistency.
              n.negate();
              d = -d;
              found = g;
              break;
            }
          }
        }

        if (!found) {
          found = { normal: n.clone(), d, triangles: [], center: new THREE.Vector3() };
          groups.push(found);
        }

        found.triangles.push({ ia, ib, ic });
      }

      // Compute centers and ensure normals point outward (convex, centered at origin)
      for (const g of groups) {
        const center = new THREE.Vector3();
        let count = 0;
        for (const t of g.triangles) {
          a.fromBufferAttribute(pos, t.ia);
          b.fromBufferAttribute(pos, t.ib);
          c.fromBufferAttribute(pos, t.ic);
          center.add(a).add(b).add(c);
          count += 3;
        }
        center.multiplyScalar(1 / Math.max(1, count));
        g.center.copy(center);
        if (g.normal.dot(center) < 0) {
          g.normal.negate();
          g.d = -g.d;
        }
      }

      return groups;
    }

    function addFaceNumberLabels(mesh, sides, faceGroups, valueByFace) {
      // Removes old face labels and adds new ones.
      if (mesh.userData.faceLabels) {
        for (const l of mesh.userData.faceLabels) mesh.remove(l);
      }
      mesh.userData.faceLabels = [];

      mesh.geometry.computeBoundingSphere();
      const rad = mesh.geometry.boundingSphere ? mesh.geometry.boundingSphere.radius : 1;
      // Keep labels very close to the surface. We rely on polygonOffset to avoid z-fighting.
      const offset = Math.max(0.004, rad * 0.012);

      const zAxis = new THREE.Vector3(0, 0, 1);
      const valueToNormal = new Map();

      const pos = mesh.geometry.getAttribute('position');
      const tmpA = new THREE.Vector3();
      const tmpB = new THREE.Vector3();
      const tmpC = new THREE.Vector3();

      for (let i = 0; i < faceGroups.length; i++) {
        const g = faceGroups[i];
        const v = valueByFace[i];
        if (!g || !Number.isFinite(v)) continue;

        // Determine a label size based on face area.
        let area = 0;
        for (const t of g.triangles) {
          tmpA.fromBufferAttribute(pos, t.ia);
          tmpB.fromBufferAttribute(pos, t.ib);
          tmpC.fromBufferAttribute(pos, t.ic);
          area += new THREE.Triangle(tmpA, tmpB, tmpC).getArea();
        }
        const labelSize = Math.max(0.20, Math.min(0.55, Math.sqrt(area) * 0.75));

        const displayText = (sides === 10 && v === 10) ? '0' : String(v);
        const label = createFaceLabelPlane(displayText, labelSize);
        label.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(zAxis, g.normal.clone().normalize()));
        label.position.copy(g.center).add(g.normal.clone().multiplyScalar(offset));
        label.renderOrder = 10;
        mesh.add(label);
        mesh.userData.faceLabels.push(label);

        // Keep internal mapping keyed by numeric value (10 stays 10 even if we display it as 0).
        if (!valueToNormal.has(v)) valueToNormal.set(v, g.normal.clone().normalize());
      }

      mesh.userData.valueToNormal = valueToNormal;
    }

    function buildOppositePairingValues(faceGroups, sides) {
      const faceCount = faceGroups.length;
      const used = new Array(faceCount).fill(false);
      const pairs = [];

      for (let i = 0; i < faceCount; i++) {
        if (used[i]) continue;
        let bestJ = -1;
        let bestDot = 1;
        for (let j = i + 1; j < faceCount; j++) {
          if (used[j]) continue;
          const dot = faceGroups[i].normal.dot(faceGroups[j].normal);
          if (dot < bestDot) {
            bestDot = dot;
            bestJ = j;
          }
        }
        if (bestJ >= 0) {
          used[i] = true;
          used[bestJ] = true;
          pairs.push([i, bestJ]);
        }
      }

      const valueByFace = new Array(faceCount).fill(null);
      const sum = sides + 1;
      let next = 1;
      for (const [a, b] of pairs) {
        valueByFace[a] = next;
        valueByFace[b] = sum - next;
        next++;
      }
      for (let i = 0; i < faceCount; i++) {
        if (valueByFace[i] == null) {
          valueByFace[i] = Math.min(sides, next);
          next++;
        }
      }
      return valueByFace;
    }

    function buildOppositePairs(faceGroups) {
      // For each face i, find its most-opposite face j (minimum dot).
      // Then keep only symmetric pairs where opp[opp[i]] === i.
      const n = faceGroups.length;
      if (n < 2) return [];

      const opp = new Array(n).fill(-1);
      for (let i = 0; i < n; i++) {
        let bestJ = -1;
        let bestDot = 2;
        const ni = faceGroups[i].normal;
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          const d = ni.dot(faceGroups[j].normal);
          if (d < bestDot) {
            bestDot = d;
            bestJ = j;
          }
        }
        opp[i] = bestJ;
      }

      const seen = new Array(n).fill(false);
      const pairs = [];
      for (let i = 0; i < n; i++) {
        if (seen[i]) continue;
        const j = opp[i];
        if (j < 0 || j >= n) continue;
        if (opp[j] !== i) continue;
        if (i === j) continue;
        seen[i] = true;
        seen[j] = true;
        pairs.push(i < j ? [i, j] : [j, i]);
      }

      // Deterministic ordering so results don't shuffle between runs.
      pairs.sort((p1, p2) => {
        const a = faceGroups[p1[0]].normal;
        const b = faceGroups[p2[0]].normal;
        // Prefer higher Y (top-ish) first, then Z, then X.
        if (a.y !== b.y) return b.y - a.y;
        if (a.z !== b.z) return b.z - a.z;
        return b.x - a.x;
      });

      return pairs;
    }

    function buildOppositeSumValues(faceGroups, sides, sum = sides + 1) {
      const pairs = buildOppositePairs(faceGroups);
      if (pairs.length * 2 !== faceGroups.length) return null;

      const valueByFace = new Array(faceGroups.length).fill(null);
      for (let k = 0; k < pairs.length; k++) {
        const low = k + 1;
        const high = sum - low;
        const [a, b] = pairs[k];
        valueByFace[a] = low;
        valueByFace[b] = high;
      }

      // Safety: ensure all assigned.
      if (valueByFace.some(v => v == null)) return null;
      return valueByFace;
    }

    function buildD10Values(faceGroups) {
      // D&D d10: faces typically labeled 1..9 and 0 (meaning 10).
      // Convention: opposite faces sum to 11 when treating 0 as 10.
      return buildOppositeSumValues(faceGroups, 10, 11);
    }

    function findFaceIndexByNormal(faceGroups, target, dotThreshold = 0.94) {
      let best = -1;
      let bestDot = -1;
      for (let i = 0; i < faceGroups.length; i++) {
        const d = faceGroups[i].normal.dot(target);
        if (d > bestDot) {
          bestDot = d;
          best = i;
        }
      }
      return bestDot >= dotThreshold ? best : -1;
    }

    function buildD6Values(faceGroups) {
      // Standard d6: opposites sum to 7 and right-handed (1 top, 2 front, 3 right).
      const v = new Array(faceGroups.length).fill(null);
      const px = new THREE.Vector3(1, 0, 0);
      const nx = new THREE.Vector3(-1, 0, 0);
      const py = new THREE.Vector3(0, 1, 0);
      const ny = new THREE.Vector3(0, -1, 0);
      const pz = new THREE.Vector3(0, 0, 1);
      const nz = new THREE.Vector3(0, 0, -1);

      const top = findFaceIndexByNormal(faceGroups, py);
      const bot = findFaceIndexByNormal(faceGroups, ny);
      const front = findFaceIndexByNormal(faceGroups, pz);
      const back = findFaceIndexByNormal(faceGroups, nz);
      const right = findFaceIndexByNormal(faceGroups, px);
      const left = findFaceIndexByNormal(faceGroups, nx);

      if ([top, bot, front, back, right, left].some(i => i < 0)) return null;

      v[top] = 1;
      v[bot] = 6;
      v[front] = 2;
      v[back] = 5;
      v[right] = 3;
      v[left] = 4;
      return v;
    }

    function buildD8Values(faceGroups) {
      // Deterministic d8 mapping by normal octant; opposites sum to 9.
      // This may not match every physical manufacturer, but it's consistent.
      const v = new Array(faceGroups.length).fill(null);
      const map = new Map();
      // Key by sign triple of normal components.
      map.set('+++', 1);
      map.set('---', 8);
      map.set('++-', 2);
      map.set('--+', 7);
      map.set('+-+', 3);
      map.set('-+-', 6);
      map.set('+--', 4);
      map.set('-++', 5);

      for (let i = 0; i < faceGroups.length; i++) {
        const n = faceGroups[i].normal;
        const sx = n.x >= 0 ? '+' : '-';
        const sy = n.y >= 0 ? '+' : '-';
        const sz = n.z >= 0 ? '+' : '-';
        const key = sx + sy + sz;
        const val = map.get(key);
        if (!val) return null;
        v[i] = val;
      }

      return v;
    }

    function makeDie(sides, geometry, x, faceGroups, valueByFace) {
      const mesh = new THREE.Mesh(geometry, baseMat.clone());
      mesh.castShadow = true;
      mesh.receiveShadow = false;
      mesh.userData = { sides };

      // Slightly different tint per die
      const tints = {
        4: 0xe5e7eb,
        6: 0xf8fafc,
        8: 0xe2e8f0,
        10: 0xf1f5f9,
        12: 0xe7e5e4,
        20: 0xf5f5f4,
      };
      mesh.material.color.setHex(tints[sides] || 0xf3f4f6);
      // Ensure cloned materials keep the same shading model and pick up env changes.
      mesh.material.flatShading = true;
      mesh.material.needsUpdate = true;

      // Place dice near the top of the tray.
      mesh.position.set(x, 2.2, 0);
      // Friendly isometric-ish pose.
      mesh.rotation.set(0.65, 0.55, 0.08);

      // Add per-face numbers.
      addFaceNumberLabels(mesh, sides, faceGroups, valueByFace);

      return mesh;
    }

    const dice = [];
    const geometries = [
      [4, new THREE.TetrahedronGeometry(0.78, 0)],
      [6, new THREE.BoxGeometry(1.05, 1.05, 1.05)],
      [8, new THREE.OctahedronGeometry(0.82, 0)],
      [10, createD10Geometry(0.86)],
      [12, new THREE.DodecahedronGeometry(0.86, 0)],
      [20, new THREE.IcosahedronGeometry(0.9, 0)],
    ];

    const spacing = 1.65;
    const startX = -((geometries.length - 1) * spacing) / 2;

    for (let i = 0; i < geometries.length; i++) {
      const [sides, geo] = geometries[i];
      const x = startX + i * spacing;

      let faceGroups;
      let valueByFace;

      {
        faceGroups = computeFaceGroups(geo);
        if (sides === 4 && faceGroups.length === 4) {
          // User-requested: put 1,2,3,4 on the d4 faces.
          valueByFace = [1, 2, 3, 4];
        } else if (sides === 6 && faceGroups.length >= 6) {
          valueByFace = buildD6Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else if (sides === 8 && faceGroups.length === 8) {
          valueByFace = buildD8Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else if (sides === 10 && faceGroups.length === 10) {
          valueByFace = buildD10Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else if ((sides === 12 || sides === 20) && faceGroups.length === sides) {
          // D12: opposites sum to 13. D20: opposites sum to 21.
          valueByFace = buildOppositeSumValues(faceGroups, sides) || buildOppositePairingValues(faceGroups, sides);
        } else {
          valueByFace = buildOppositePairingValues(faceGroups, sides);
        }
      }

      const mesh = makeDie(sides, geo, x, faceGroups, valueByFace);
      const lines = makeEdges(mesh);
      scene.add(mesh);
      scene.add(lines);
      dice.push({ mesh, lines, sides, anim: null });
    }

    function resize() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);
    resize();

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function postDie(sides) {
      const payload = JSON.stringify({ type: 'die', sides });
      if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
        window.chrome.webview.postMessage(payload);
      }
    }

    function postRotate(sides, q) {
      // q is a THREE.Quaternion
      const payload = JSON.stringify({ type: 'rotate', sides, q: [q.x, q.y, q.z, q.w] });
      if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
        window.chrome.webview.postMessage(payload);
      }
    }

    function pickDieAt(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((clientY - rect.top) / rect.height) * 2 - 1);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(dice.map(d => d.mesh), false);
      if (hits.length <= 0) return null;
      const hitMesh = hits[0].object;
      return dice.find(d => d.mesh === hitMesh) || null;
    }

    // Click = roll, drag = rotate die for inspection.
    let activeDrag = null; // { die, pointerId, startX, startY, lastX, lastY, dragging, lastSentMs }
    const DRAG_THRESHOLD_PX = 4;
    const ROT_SPEED = 0.007;
    const ROT_SEND_INTERVAL_MS = 33;

    canvas.addEventListener('pointerdown', (ev) => {
      // Only primary button / primary touch.
      if (ev.isPrimary === false) return;
      if (ev.button != null && ev.button !== 0) return;

      const die = pickDieAt(ev.clientX, ev.clientY);
      if (!die) return;

      activeDrag = {
        die,
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        lastX: ev.clientX,
        lastY: ev.clientY,
        dragging: false,
        lastSentMs: 0,
      };

      try { canvas.setPointerCapture(ev.pointerId); } catch { }
      ev.preventDefault();
    });

    canvas.addEventListener('pointermove', (ev) => {
      if (!activeDrag) return;
      if (ev.pointerId !== activeDrag.pointerId) return;

      const dxTotal = ev.clientX - activeDrag.startX;
      const dyTotal = ev.clientY - activeDrag.startY;
      const dist = Math.hypot(dxTotal, dyTotal);
      if (!activeDrag.dragging && dist >= DRAG_THRESHOLD_PX) {
        activeDrag.dragging = true;
        // Cancel any roll animation while inspecting.
        activeDrag.die.anim = null;
      }

      if (activeDrag.dragging) {
        const dx = ev.clientX - activeDrag.lastX;
        const dy = ev.clientY - activeDrag.lastY;

        // Horizontal drag: spin around world up.
        activeDrag.die.mesh.rotateOnWorldAxis(UP, dx * ROT_SPEED);

        // Vertical drag: tilt around camera-right axis so it feels natural.
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
        activeDrag.die.mesh.rotateOnWorldAxis(right, dy * ROT_SPEED);

        const now = performance.now();
        if ((now - activeDrag.lastSentMs) >= ROT_SEND_INTERVAL_MS) {
          activeDrag.lastSentMs = now;
          postRotate(activeDrag.die.sides, activeDrag.die.mesh.quaternion);
        }
      }

      activeDrag.lastX = ev.clientX;
      activeDrag.lastY = ev.clientY;
      ev.preventDefault();
    });

    function endDrag(ev) {
      if (!activeDrag) return;
      if (ev.pointerId !== activeDrag.pointerId) return;

      const die = activeDrag.die;
      const shouldClick = !activeDrag.dragging;

      try { canvas.releasePointerCapture(ev.pointerId); } catch { }
      activeDrag = null;

      if (shouldClick && die) {
        postDie(die.sides);
      } else if (die) {
        // Send final rotation on drag end.
        postRotate(die.sides, die.mesh.quaternion);
      }

      ev.preventDefault();
    }

    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', endDrag);

    function applyIdlePose(d) {
      d.mesh.rotation.set(0.65, 0.55, 0.08);
      d.anim = null;
    }

    const UP = new THREE.Vector3(0, 1, 0);

    function quaternionForValue(mesh, value) {
      const map = mesh.userData.valueToNormal;
      if (!map || !map.get) return null;
      const n = map.get(value);
      if (!n) return null;
      const q = new THREE.Quaternion().setFromUnitVectors(n.clone().normalize(), UP);
      const yaw = new THREE.Quaternion().setFromAxisAngle(UP, (Math.random() * Math.PI * 2));
      q.multiply(yaw);
      return q;
    }

    function kickRollToValue(d, value) {
      const target = quaternionForValue(d.mesh, value);
      const start = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random() * 2.2, Math.random() * 2.2, Math.random() * 2.2));
      d.mesh.quaternion.copy(start);

      d.anim = {
        t: 0,
        duration: 1.05,
        start,
        target: target || new THREE.Quaternion().setFromEuler(new THREE.Euler(0.65, 0.55, 0.08)),
      };
    }

    function setPreview() {
      for (const d of dice) {
        applyIdlePose(d);
      }
    }

    function showRollResults(items) {
      // items: [{sides,value}]
      const buckets = new Map();
      for (const it of items || []) {
        const s = Number(it.sides);
        let v = Number(it.value);
        if (!Number.isFinite(s) || !Number.isFinite(v)) continue;

        // d10 may come through as 0 (meaning 10) depending on upstream formatting.
        if (s === 10 && v === 0) v = 10;

        if (!buckets.has(s)) buckets.set(s, []);
        buckets.get(s).push(v);
      }

      for (const d of dice) {
        const values = buckets.get(d.sides) || [];
        if (values.length > 0) {
          const v = values.shift();
          kickRollToValue(d, v);
        } else {
          applyIdlePose(d);
        }
      }
    }

    // Messages from host (C#): {type:'preview'} or {type:'roll', dice:[{sides,value}]}
    if (window.chrome && window.chrome.webview) {
      window.chrome.webview.addEventListener('message', (ev) => {
        try {
          const msg = typeof ev.data === 'string' ? JSON.parse(ev.data) : ev.data;
          if (!msg || !msg.type) return;
          if (msg.type === 'preview') setPreview();
          if (msg.type === 'roll') showRollResults(msg.dice || []);
          if (msg.type === 'setRotation') {
            const sides = Number(msg.sides);
            const q = msg.q;
            if (!Number.isFinite(sides) || !Array.isArray(q) || q.length !== 4) return;
            const d = dice.find(dd => dd.sides === sides);
            if (!d) return;
            const x = Number(q[0]);
            const y = Number(q[1]);
            const z = Number(q[2]);
            const w = Number(q[3]);
            if (![x, y, z, w].every(Number.isFinite)) return;
            d.anim = null;
            d.mesh.quaternion.set(x, y, z, w).normalize();
          }
        } catch { }
      });
    }

    setPreview();

    let t0 = performance.now();
    function animate() {
      const t = performance.now();
      const dt = (t - t0) / 1000;
      t0 = t;

      for (const d of dice) {
        if (d.anim) {
          d.anim.t += dt;
          const u = Math.min(1, d.anim.t / d.anim.duration);
          const s = u * u * (3 - 2 * u);

          d.mesh.quaternion.slerpQuaternions(d.anim.start, d.anim.target, s);

          // mild settle wobble early
          if (u < 0.85) {
            const wob = (1 - u) * 0.08;
            d.mesh.rotateX(Math.sin(t * 0.009) * wob);
            d.mesh.rotateZ(Math.cos(t * 0.011) * wob);
          }

          if (u >= 1) {
            d.anim = null;
          }
        }

        d.lines.position.copy(d.mesh.position);
        d.lines.quaternion.copy(d.mesh.quaternion);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
