<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScryScreen Dice Tray</title>
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#0A0F18; }
    #c { display:block; width:100%; height:100%; }
    .hint { position:absolute; left:10px; top:8px; color:#94a3b8; font: 12px/1.2 system-ui, Segoe UI, sans-serif; opacity:0.85; user-select:none; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Click a die: d4 d6 d8 d10 d12 d20</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setClearColor(0x0A0F18, 1);
    // Unlit mode: keep dice readable everywhere; no lighting required.
    renderer.physicallyCorrectLights = false;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMappingExposure = 1.0;

    const scene = new THREE.Scene();

    // Unlit mode: no reflections/environment lighting.
    scene.environment = null;

    // Camera is framed so dice live near the *top* of the view.
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 60);
    camera.position.set(0, 6.0, 11.0);
    camera.lookAt(0, 2.5, 0);

    renderer.shadowMap.enabled = false;

    const baseMat = new THREE.MeshBasicMaterial({
      color: 0xf3f4f6,
      toneMapped: false,
    });

    function makeEdges(mesh) {
      const eg = new THREE.EdgesGeometry(mesh.geometry, 25);
      const lm = new THREE.LineBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.8 });
      const lines = new THREE.LineSegments(eg, lm);
      lines.position.copy(mesh.position);
      lines.quaternion.copy(mesh.quaternion);
      lines.scale.copy(mesh.scale);
      return lines;
    }

    function ensureOutwardWinding(geometry) {
      // Fixes triangle winding so faces render with FrontSide materials.
      // For convex polyhedra centered at origin, outward normals satisfy normal·centroid > 0.
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      if (!pos || !index) return;

      const a = new THREE.Vector3();
      const b = new THREE.Vector3();
      const c = new THREE.Vector3();
      const ab = new THREE.Vector3();
      const ac = new THREE.Vector3();
      const n = new THREE.Vector3();
      const centroid = new THREE.Vector3();

      for (let i = 0; i < index.count; i += 3) {
        const ia = index.getX(i);
        const ib = index.getX(i + 1);
        const ic = index.getX(i + 2);
        a.fromBufferAttribute(pos, ia);
        b.fromBufferAttribute(pos, ib);
        c.fromBufferAttribute(pos, ic);

        ab.copy(b).sub(a);
        ac.copy(c).sub(a);
        n.copy(ab).cross(ac);
        centroid.copy(a).add(b).add(c).multiplyScalar(1 / 3);

        if (n.dot(centroid) < 0) {
          // Swap winding
          index.setX(i + 1, ic);
          index.setX(i + 2, ib);
        }
      }

      index.needsUpdate = true;
    }

    // D10: pentagonal trapezohedron built as indexed triangles.
    // Important: the two triangles that make each kite must be coplanar, otherwise
    // EdgesGeometry will show the diagonal and the shape looks "broken".
    function createD10Geometry(radius = 0.86) {
      const n = 5;

      // Planarity constraint for this construction: apexDistance / ringPlaneOffset ≈ 9.472135955
      const apexToPlane = 9.47213595499958;

      const apexY = radius * 0.90;
      const ringY = apexY / apexToPlane;
      const r = radius * 0.82;

      // Vertex layout (Y-up):
      // 0 = top apex, 1 = bottom apex, 2..6 = U0..U4, 7..11 = L0..L4
      const verts = [];
      verts.push([0, +apexY, 0]);
      verts.push([0, -apexY, 0]);

      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * k) / n;
        verts.push([Math.cos(a) * r, +ringY, Math.sin(a) * r]);
      }
      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * (k + 0.5)) / n;
        verts.push([Math.cos(a) * r, -ringY, Math.sin(a) * r]);
      }

      const idx = [];
      const T = 0;
      const B = 1;
      const U0 = 2;
      const L0 = 7;

      // Each kite face is split into two triangles.
      // Top kites: [T, U_k, L_k, U_{k+1}]
      for (let k = 0; k < n; k++) {
        const Uk = U0 + k;
        const Uk1 = U0 + ((k + 1) % n);
        const Lk = L0 + k;
        idx.push(T, Uk, Lk);
        idx.push(T, Lk, Uk1);
      }
      // Bottom kites: [B, L_k, U_{k+1}, L_{k+1}]
      for (let k = 0; k < n; k++) {
        const Lk = L0 + k;
        const Lk1 = L0 + ((k + 1) % n);
        const Uk1 = U0 + ((k + 1) % n);
        idx.push(B, Lk, Uk1);
        idx.push(B, Uk1, Lk1);
      }

      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts.flat()), 3));
      g.setIndex(idx);
      ensureOutwardWinding(g);
      g.computeVertexNormals();
      g.computeBoundingBox();
      g.computeBoundingSphere();
      return g;
    }

    function createFaceLabelTexture(text) {
      const canvas = document.createElement('canvas');
      // Higher resolution keeps labels readable even when many dice are on screen.
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.font = 'bold 240px system-ui, Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Readability: treat the label as printed ink that should remain legible even
      // when the underlying face is in shadow.
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 2;

      // Outline for contrast.
      ctx.lineWidth = 22;
      ctx.strokeStyle = 'rgba(0,0,0,0.92)';
      ctx.strokeText(String(text), 256, 256);
      ctx.fillStyle = 'rgba(245,245,245,0.98)';
      ctx.fillText(String(text), 256, 256);

      const tex = new THREE.CanvasTexture(canvas);
      // Improve sharpness when labels are slightly tilted.
      tex.anisotropy = 16;
      // Avoid overly-blurry small text; use linear filtering.
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      try {
        // three r152+
        tex.colorSpace = THREE.SRGBColorSpace;
      } catch { }
      tex.needsUpdate = true;
      return { canvas, ctx, tex };
    }

    function createFaceLabelPlane(text, scale = 0.45) {
      const plate = createFaceLabelTexture(text);
      const mat = new THREE.MeshBasicMaterial({
        map: plate.tex,
        transparent: true,
        // Cut out the transparent background to keep numbers crisp.
        alphaTest: 0.35,
        depthTest: true,
        depthWrite: false,
        // Only show the label from the outside of the die.
        side: THREE.FrontSide,
        toneMapped: false,
        // Keep the label visually "printed" on the face without needing a large offset.
        polygonOffset: true,
        polygonOffsetFactor: -6,
        polygonOffsetUnits: -6,
      });
      const geo = new THREE.PlaneGeometry(scale, scale);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData._label = plate;
      return mesh;
    }

    function computeFaceGroups(geometry) {
      // Returns array of { normal, center, triangles:[{ia,ib,ic}] } for coplanar face groups.
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      if (!pos) return [];

      const epsDot = 0.9995;
      const epsD = 1e-3;
      const groups = [];

      const a = new THREE.Vector3();
      const b = new THREE.Vector3();
      const c = new THREE.Vector3();
      const n = new THREE.Vector3();
      const tmp = new THREE.Vector3();

      const triCount = index ? index.count : pos.count;
      for (let i = 0; i < triCount; i += 3) {
        const ia = index ? index.getX(i) : i;
        const ib = index ? index.getX(i + 1) : (i + 1);
        const ic = index ? index.getX(i + 2) : (i + 2);
        a.fromBufferAttribute(pos, ia);
        b.fromBufferAttribute(pos, ib);
        c.fromBufferAttribute(pos, ic);

        n.copy(b).sub(a).cross(tmp.copy(c).sub(a)).normalize();
        if (!Number.isFinite(n.x)) continue;
        let d = -n.dot(a);

        let found = null;
        for (const g of groups) {
          const dot = g.normal.dot(n);
          if (Math.abs(dot) <= epsDot) continue;

          if (dot > 0) {
            // Same normal direction -> same plane means d matches.
            if (Math.abs(g.d - d) < epsD) {
              found = g;
              break;
            }
          } else {
            // Opposite normal direction -> same plane means d is negated.
            if (Math.abs(g.d + d) < epsD) {
              // Align to group orientation for consistency.
              n.negate();
              d = -d;
              found = g;
              break;
            }
          }
        }

        if (!found) {
          found = { normal: n.clone(), d, triangles: [], center: new THREE.Vector3() };
          groups.push(found);
        }

        found.triangles.push({ ia, ib, ic });
      }

      // Compute centers and ensure normals point outward (convex, centered at origin)
      for (const g of groups) {
        const center = new THREE.Vector3();
        let count = 0;
        for (const t of g.triangles) {
          a.fromBufferAttribute(pos, t.ia);
          b.fromBufferAttribute(pos, t.ib);
          c.fromBufferAttribute(pos, t.ic);
          center.add(a).add(b).add(c);
          count += 3;
        }
        center.multiplyScalar(1 / Math.max(1, count));
        g.center.copy(center);
        if (g.normal.dot(center) < 0) {
          g.normal.negate();
          g.d = -g.d;
        }
      }

      return groups;
    }

    function addFaceNumberLabels(mesh, sides, faceGroups, valueByFace) {
      // Removes old face labels and adds new ones.
      if (mesh.userData.faceLabels) {
        for (const l of mesh.userData.faceLabels) mesh.remove(l);
      }
      mesh.userData.faceLabels = [];

      mesh.geometry.computeBoundingSphere();
      const rad = mesh.geometry.boundingSphere ? mesh.geometry.boundingSphere.radius : 1;
      // Keep labels very close to the surface. We rely on polygonOffset to avoid z-fighting.
      const offset = Math.max(0.010, rad * 0.030);

      const zAxis = new THREE.Vector3(0, 0, 1);
      const valueToNormal = new Map();
      const valueToFrame = new Map();

      const pos = mesh.geometry.getAttribute('position');
      const tmpA = new THREE.Vector3();
      const tmpB = new THREE.Vector3();
      const tmpC = new THREE.Vector3();
      const tmpU = new THREE.Vector3();

      for (let i = 0; i < faceGroups.length; i++) {
        const g = faceGroups[i];
        const v = valueByFace[i];
        if (!g || !Number.isFinite(v)) continue;

        // Determine a label size based on face area.
        let area = 0;
        for (const t of g.triangles) {
          tmpA.fromBufferAttribute(pos, t.ia);
          tmpB.fromBufferAttribute(pos, t.ib);
          tmpC.fromBufferAttribute(pos, t.ic);
          area += new THREE.Triangle(tmpA, tmpB, tmpC).getArea();
        }
        const labelSize = Math.max(0.24, Math.min(0.62, Math.sqrt(area) * 0.90));

        const displayText = (sides === 10 && v === 10) ? '0' : String(v);
        const label = createFaceLabelPlane(displayText, labelSize);
        label.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(zAxis, g.normal.clone().normalize()));
        label.position.copy(g.center).add(g.normal.clone().multiplyScalar(offset));
        label.renderOrder = 10;
        mesh.add(label);
        mesh.userData.faceLabels.push(label);

        // Keep internal mapping keyed by numeric value (10 stays 10 even if we display it as 0).
        if (!valueToNormal.has(v)) valueToNormal.set(v, g.normal.clone().normalize());

        // Also store a stable in-face tangent so we can align the face upright to the camera.
        // Pick a representative vertex direction from center and project it onto the face plane.
        let ia0 = null;
        if (g.triangles && g.triangles.length > 0) {
          ia0 = g.triangles[0].ia;
        }
        if (ia0 != null) {
          tmpA.fromBufferAttribute(pos, ia0);
          tmpU.copy(tmpA).sub(g.center);
          const nn = g.normal.clone().normalize();
          tmpU.sub(nn.clone().multiplyScalar(tmpU.dot(nn)));
          if (tmpU.lengthSq() > 1e-8) {
            tmpU.normalize();
            if (!valueToFrame.has(v)) valueToFrame.set(v, { normal: nn, u: tmpU.clone() });
          }
        }
      }

      mesh.userData.valueToNormal = valueToNormal;
      mesh.userData.valueToFrame = valueToFrame;
    }

    function buildOppositePairingValues(faceGroups, sides) {
      const faceCount = faceGroups.length;
      const used = new Array(faceCount).fill(false);
      const pairs = [];

      for (let i = 0; i < faceCount; i++) {
        if (used[i]) continue;
        let bestJ = -1;
        let bestDot = 1;
        for (let j = i + 1; j < faceCount; j++) {
          if (used[j]) continue;
          const dot = faceGroups[i].normal.dot(faceGroups[j].normal);
          if (dot < bestDot) {
            bestDot = dot;
            bestJ = j;
          }
        }
        if (bestJ >= 0) {
          used[i] = true;
          used[bestJ] = true;
          pairs.push([i, bestJ]);
        }
      }

      const valueByFace = new Array(faceCount).fill(null);
      const sum = sides + 1;
      let next = 1;
      for (const [a, b] of pairs) {
        valueByFace[a] = next;
        valueByFace[b] = sum - next;
        next++;
      }
      for (let i = 0; i < faceCount; i++) {
        if (valueByFace[i] == null) {
          valueByFace[i] = Math.min(sides, next);
          next++;
        }
      }
      return valueByFace;
    }

    function buildOppositePairs(faceGroups) {
      // For each face i, find its most-opposite face j (minimum dot).
      // Then keep only symmetric pairs where opp[opp[i]] === i.
      const n = faceGroups.length;
      if (n < 2) return [];

      const opp = new Array(n).fill(-1);
      for (let i = 0; i < n; i++) {
        let bestJ = -1;
        let bestDot = 2;
        const ni = faceGroups[i].normal;
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          const d = ni.dot(faceGroups[j].normal);
          if (d < bestDot) {
            bestDot = d;
            bestJ = j;
          }
        }
        opp[i] = bestJ;
      }

      const seen = new Array(n).fill(false);
      const pairs = [];
      for (let i = 0; i < n; i++) {
        if (seen[i]) continue;
        const j = opp[i];
        if (j < 0 || j >= n) continue;
        if (opp[j] !== i) continue;
        if (i === j) continue;
        seen[i] = true;
        seen[j] = true;
        pairs.push(i < j ? [i, j] : [j, i]);
      }

      // Deterministic ordering so results don't shuffle between runs.
      pairs.sort((p1, p2) => {
        const a = faceGroups[p1[0]].normal;
        const b = faceGroups[p2[0]].normal;
        // Prefer higher Y (top-ish) first, then Z, then X.
        if (a.y !== b.y) return b.y - a.y;
        if (a.z !== b.z) return b.z - a.z;
        return b.x - a.x;
      });

      return pairs;
    }

    function buildOppositeSumValues(faceGroups, sides, sum = sides + 1) {
      const pairs = buildOppositePairs(faceGroups);
      if (pairs.length * 2 !== faceGroups.length) return null;

      const valueByFace = new Array(faceGroups.length).fill(null);
      for (let k = 0; k < pairs.length; k++) {
        const low = k + 1;
        const high = sum - low;
        const [a, b] = pairs[k];
        valueByFace[a] = low;
        valueByFace[b] = high;
      }

      // Safety: ensure all assigned.
      if (valueByFace.some(v => v == null)) return null;
      return valueByFace;
    }

    function buildD10Values(faceGroups) {
      // D&D d10: faces typically labeled 1..9 and 0 (meaning 10).
      // Convention: opposite faces sum to 11 when treating 0 as 10.
      return buildOppositeSumValues(faceGroups, 10, 11);
    }

    function findFaceIndexByNormal(faceGroups, target, dotThreshold = 0.94) {
      let best = -1;
      let bestDot = -1;
      for (let i = 0; i < faceGroups.length; i++) {
        const d = faceGroups[i].normal.dot(target);
        if (d > bestDot) {
          bestDot = d;
          best = i;
        }
      }
      return bestDot >= dotThreshold ? best : -1;
    }

    function buildD6Values(faceGroups) {
      // Standard d6: opposites sum to 7 and right-handed (1 top, 2 front, 3 right).
      const v = new Array(faceGroups.length).fill(null);
      const px = new THREE.Vector3(1, 0, 0);
      const nx = new THREE.Vector3(-1, 0, 0);
      const py = new THREE.Vector3(0, 1, 0);
      const ny = new THREE.Vector3(0, -1, 0);
      const pz = new THREE.Vector3(0, 0, 1);
      const nz = new THREE.Vector3(0, 0, -1);

      const top = findFaceIndexByNormal(faceGroups, py);
      const bot = findFaceIndexByNormal(faceGroups, ny);
      const front = findFaceIndexByNormal(faceGroups, pz);
      const back = findFaceIndexByNormal(faceGroups, nz);
      const right = findFaceIndexByNormal(faceGroups, px);
      const left = findFaceIndexByNormal(faceGroups, nx);

      if ([top, bot, front, back, right, left].some(i => i < 0)) return null;

      v[top] = 1;
      v[bot] = 6;
      v[front] = 2;
      v[back] = 5;
      v[right] = 3;
      v[left] = 4;
      return v;
    }

    function buildD8Values(faceGroups) {
      // Deterministic d8 mapping by normal octant; opposites sum to 9.
      // This may not match every physical manufacturer, but it's consistent.
      const v = new Array(faceGroups.length).fill(null);
      const map = new Map();
      // Key by sign triple of normal components.
      map.set('+++', 1);
      map.set('---', 8);
      map.set('++-', 2);
      map.set('--+', 7);
      map.set('+-+', 3);
      map.set('-+-', 6);
      map.set('+--', 4);
      map.set('-++', 5);

      for (let i = 0; i < faceGroups.length; i++) {
        const n = faceGroups[i].normal;
        const sx = n.x >= 0 ? '+' : '-';
        const sy = n.y >= 0 ? '+' : '-';
        const sz = n.z >= 0 ? '+' : '-';
        const key = sx + sy + sz;
        const val = map.get(key);
        if (!val) return null;
        v[i] = val;
      }

      return v;
    }

    function makeDie(sides, geometry, faceGroups, valueByFace) {
      const mesh = new THREE.Mesh(geometry, baseMat.clone());
      mesh.castShadow = true;
      mesh.receiveShadow = false;
      mesh.userData = { sides };

      // User request: dice should be half the size.
      mesh.scale.setScalar(DICE_SCALE);

      // Slightly different tint per die
      const tints = {
        4: 0xe5e7eb,
        6: 0xf8fafc,
        8: 0xe2e8f0,
        10: 0xf1f5f9,
        12: 0xe7e5e4,
        20: 0xf5f5f4,
      };
      mesh.material.color.setHex(tints[sides] || 0xf3f4f6);
      // Ensure cloned materials keep the same shading model and pick up env changes.
      mesh.material.flatShading = true;
      mesh.material.needsUpdate = true;

      // Add per-face numbers.
      addFaceNumberLabels(mesh, sides, faceGroups, valueByFace);

      return mesh;
    }

    const dice = [];
    const MAX_DICE = 30;
    let _dieInstanceCounter = 0;

    const DICE_SCALE = 0.5;
    const ROLL_LANE_Y = 2.2;
    const ROLL_LANE_Z = 0.0;
    const ROLL_AXIS_Z = new THREE.Vector3(0, 0, 1);
    const _tmpV = new THREE.Vector3();
    const _tmpTravel = new THREE.Vector3();
    const _tmpRollAxis = new THREE.Vector3();
    const _tmpRay = new THREE.Ray();
    const _tmpPlane = new THREE.Plane();
    const _rollPlanePoint = new THREE.Vector3();
    const _rollPlaneNormal = new THREE.Vector3();
    const _rollPlaneRight = new THREE.Vector3();
    const _rollPlaneUp = new THREE.Vector3();
    const _tmpQ0 = new THREE.Quaternion();
    const _tmpQ1 = new THREE.Quaternion();
    const _tmpQRock = new THREE.Quaternion();
    const _tmpHit = new THREE.Vector3();
    const _tmpRel = new THREE.Vector3();
    const _tmpPos = new THREE.Vector3();
    const geometries = [
      [4, new THREE.TetrahedronGeometry(0.78, 0)],
      [6, new THREE.BoxGeometry(1.05, 1.05, 1.05)],
      [8, new THREE.OctahedronGeometry(0.82, 0)],
      [10, createD10Geometry(0.86)],
      [12, new THREE.DodecahedronGeometry(0.86, 0)],
      [20, new THREE.IcosahedronGeometry(0.9, 0)],
    ];

    // Build reusable templates. Dice meshes are spawned only when you request a roll.
    const dieTemplates = new Map();
    for (const [sides, geo] of geometries) {
      let faceGroups = computeFaceGroups(geo);
      let valueByFace;

      if (sides === 4 && faceGroups.length === 4) {
        valueByFace = [1, 2, 3, 4];
      } else if (sides === 6 && faceGroups.length >= 6) {
        valueByFace = buildD6Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
      } else if (sides === 8 && faceGroups.length === 8) {
        valueByFace = buildD8Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
      } else if (sides === 10 && faceGroups.length === 10) {
        valueByFace = buildD10Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
      } else if ((sides === 12 || sides === 20) && faceGroups.length === sides) {
        valueByFace = buildOppositeSumValues(faceGroups, sides) || buildOppositePairingValues(faceGroups, sides);
      } else {
        valueByFace = buildOppositePairingValues(faceGroups, sides);
      }

      // Precompute base radius for collisions.
      let baseRadius = 0.85 * DICE_SCALE;
      try {
        geo.computeBoundingSphere();
        const r = geo.boundingSphere ? geo.boundingSphere.radius : 0.85;
        baseRadius = r * DICE_SCALE;
      } catch { }

      dieTemplates.set(sides, { sides, geo, faceGroups, valueByFace, baseRadius });
    }

    function findLastDieBySides(sides) {
      for (let i = dice.length - 1; i >= 0; i--) {
        if (dice[i].sides === sides) return dice[i];
      }
      return null;
    }

    function clearAllDice() {
      for (const d of dice) {
        try { scene.remove(d.mesh); } catch { }
        try { scene.remove(d.lines); } catch { }
      }
      dice.length = 0;
    }

    function spawnDie(sides) {
      const tpl = dieTemplates.get(sides);
      if (!tpl) return null;

      // Cap total dice to avoid unbounded buildup.
      if (dice.length >= MAX_DICE) {
        // Prefer removing an idle/settled die.
        let idx = dice.findIndex(dd => !dd.anim);
        if (idx < 0) idx = 0;
        const victim = dice.splice(idx, 1)[0];
        try { scene.remove(victim.mesh); } catch { }
        try { scene.remove(victim.lines); } catch { }
      }

      const mesh = makeDie(sides, tpl.geo, tpl.faceGroups, tpl.valueByFace);
      const lines = makeEdges(mesh);
      mesh.userData.radius = tpl.baseRadius;
      mesh.userData.instanceId = (++_dieInstanceCounter);
      scene.add(mesh);
      scene.add(lines);
      const d = { mesh, lines, sides, anim: null };
      dice.push(d);
      return d;
    }

    function fract(x) { return x - Math.floor(x); }
    function prng(seed) { return fract(Math.sin(seed) * 43758.5453123); }

    function slerpEase(qFrom, qTo, dt, k) {
      // Exponential ease: alpha = 1 - exp(-k * dt)
      const alpha = 1 - Math.exp(-(k || 14.0) * Math.max(0, dt));
      return Math.max(0, Math.min(1, alpha));
    }

    function worldXAtPlaneY(ndcX, ndcY, yPlane) {
      // Ray from camera through NDC point, intersect with plane Y = yPlane.
      _tmpV.set(ndcX, ndcY, 0.5).unproject(camera);
      _tmpRay.origin.copy(camera.position);
      _tmpRay.direction.copy(_tmpV).sub(camera.position).normalize();
      _tmpPlane.set(new THREE.Vector3(0, 1, 0), -yPlane);
      const hit = new THREE.Vector3();
      const ok = _tmpRay.intersectPlane(_tmpPlane, hit);
      return ok ? hit.x : 0;
    }

    function worldPointAtPlaneY(ndcX, ndcY, yPlane, out) {
      // Ray from camera through NDC point, intersect with plane Y = yPlane.
      _tmpV.set(ndcX, ndcY, 0.5).unproject(camera);
      _tmpRay.origin.copy(camera.position);
      _tmpRay.direction.copy(_tmpV).sub(camera.position).normalize();
      _tmpPlane.set(new THREE.Vector3(0, 1, 0), -yPlane);
      return _tmpRay.intersectPlane(_tmpPlane, out);
    }

    function updateRollPlaneBasis() {
      // The "screen" plane: perpendicular to camera forward, passing through the dice lane center.
      _rollPlanePoint.set(0, ROLL_LANE_Y, ROLL_LANE_Z);
      camera.getWorldDirection(_rollPlaneNormal).normalize();
      _rollPlaneRight.set(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
      _rollPlaneUp.set(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
    }

    function worldPointAtRollPlane(ndcX, ndcY, out) {
      // Ray from camera through NDC point, intersect with the roll plane.
      _tmpV.set(ndcX, ndcY, 0.5).unproject(camera);
      _tmpRay.origin.copy(camera.position);
      _tmpRay.direction.copy(_tmpV).sub(camera.position).normalize();
      _tmpPlane.set(_rollPlaneNormal, -_rollPlaneNormal.dot(_rollPlanePoint));
      return _tmpRay.intersectPlane(_tmpPlane, out);
    }

    function rollPlaneUVAtNdc(ndcX, ndcY, outUV) {
      const hit = worldPointAtRollPlane(ndcX, ndcY, _tmpHit);
      if (!hit) return null;
      _tmpRel.copy(_tmpHit).sub(_rollPlanePoint);
      outUV.u = _tmpRel.dot(_rollPlaneRight);
      outUV.v = _tmpRel.dot(_rollPlaneUp);
      return outUV;
    }

    function resize() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      updateRollPlaneBasis();
    }

    window.addEventListener('resize', resize);
    resize();

    function computeLaneBounds(out) {
      const uv = { u: 0, v: 0 };
      rollPlaneUVAtNdc(-1, 0, uv);
      const laneInset = 0.6 * DICE_SCALE;
      const uLeft = uv.u + laneInset;
      rollPlaneUVAtNdc(1, 0, uv);
      const uRight = uv.u - laneInset;
      rollPlaneUVAtNdc(0, -1, uv);
      const vMin0 = uv.v + laneInset;
      rollPlaneUVAtNdc(0, 1, uv);
      const vMax0 = uv.v - laneInset;
      const vMin = Math.min(vMin0, vMax0);
      const vMax = Math.max(vMin0, vMax0);
      out.uLeft = uLeft;
      out.uRight = uRight;
      out.vMin = vMin;
      out.vMax = vMax;
      return out;
    }

    function ensureNonOverlapAllDice() {
      if (dice.length < 2) return;

      const bounds = computeLaneBounds({ uLeft: 0, uRight: 0, vMin: 0, vMax: 0 });
      const maxIter = 2;

      for (let iter = 0; iter < maxIter; iter++) {
        for (let i = 0; i < dice.length; i++) {
          for (let j = i + 1; j < dice.length; j++) {
            const a = dice[i];
            const b = dice[j];

            _tmpRel.copy(a.mesh.position).sub(_rollPlanePoint);
            const au0 = _tmpRel.dot(_rollPlaneRight);
            const av0 = _tmpRel.dot(_rollPlaneUp);
            _tmpRel.copy(b.mesh.position).sub(_rollPlanePoint);
            const bu0 = _tmpRel.dot(_rollPlaneRight);
            const bv0 = _tmpRel.dot(_rollPlaneUp);

            const du = au0 - bu0;
            const dv = av0 - bv0;
            const dist = Math.hypot(du, dv);
            const r1 = (a.mesh.userData && Number.isFinite(a.mesh.userData.radius)) ? a.mesh.userData.radius : 0.85;
            const r2 = (b.mesh.userData && Number.isFinite(b.mesh.userData.radius)) ? b.mesh.userData.radius : 0.85;
            const minDist = Math.max(0.001, r1 + r2);
            if (dist >= minDist) continue;

            const nx = dist > 1e-6 ? (du / dist) : 1;
            const nz = dist > 1e-6 ? (dv / dist) : 0;
            const pen = (minDist - dist) + 1e-3;
            const push = pen * 0.5;

            const aHasUV = a.anim && Number.isFinite(a.anim.u) && Number.isFinite(a.anim.v);
            const bHasUV = b.anim && Number.isFinite(b.anim.u) && Number.isFinite(b.anim.v);
            const au = aHasUV ? a.anim.u : au0;
            const av = aHasUV ? a.anim.v : av0;
            const bu = bHasUV ? b.anim.u : bu0;
            const bv = bHasUV ? b.anim.v : bv0;

            let nau = au + nx * push;
            let nav = av + nz * push;
            let nbu = bu - nx * push;
            let nbv = bv - nz * push;

            nau = Math.min(bounds.uRight, Math.max(bounds.uLeft, nau));
            nav = Math.min(bounds.vMax, Math.max(bounds.vMin, nav));
            nbu = Math.min(bounds.uRight, Math.max(bounds.uLeft, nbu));
            nbv = Math.min(bounds.vMax, Math.max(bounds.vMin, nbv));

            if (aHasUV) { a.anim.u = nau; a.anim.v = nav; }
            if (bHasUV) { b.anim.u = nbu; b.anim.v = nbv; }

            a.mesh.position.copy(_rollPlanePoint)
              .addScaledVector(_rollPlaneRight, nau)
              .addScaledVector(_rollPlaneUp, nav);
            b.mesh.position.copy(_rollPlanePoint)
              .addScaledVector(_rollPlaneRight, nbu)
              .addScaledVector(_rollPlaneUp, nbv);
          }
        }
      }
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function postDie(sides) {
      const payload = JSON.stringify({ type: 'die', sides });
      if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
        window.chrome.webview.postMessage(payload);
      }
    }

    function postRotate(sides, q) {
      // q is a THREE.Quaternion
      const payload = JSON.stringify({ type: 'rotate', sides, q: [q.x, q.y, q.z, q.w] });
      if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
        window.chrome.webview.postMessage(payload);
      }
    }

    function pickDieAt(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((clientY - rect.top) / rect.height) * 2 - 1);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(dice.map(d => d.mesh), false);
      if (hits.length <= 0) return null;
      const hitMesh = hits[0].object;
      return dice.find(d => d.mesh === hitMesh) || null;
    }

    // Click = roll, drag = rotate die for inspection.
    let activeDrag = null; // { die, pointerId, startX, startY, lastX, lastY, dragging, lastSentMs }
    const DRAG_THRESHOLD_PX = 4;
    const ROT_SPEED = 0.007;
    const ROT_SEND_INTERVAL_MS = 33;

    canvas.addEventListener('pointerdown', (ev) => {
      // Only primary button / primary touch.
      if (ev.isPrimary === false) return;
      if (ev.button != null && ev.button !== 0) return;

      const die = pickDieAt(ev.clientX, ev.clientY);
      if (!die) return;

      activeDrag = {
        die,
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        lastX: ev.clientX,
        lastY: ev.clientY,
        dragging: false,
        lastSentMs: 0,
      };

      try { canvas.setPointerCapture(ev.pointerId); } catch { }
      ev.preventDefault();
    });

    canvas.addEventListener('pointermove', (ev) => {
      if (!activeDrag) return;
      if (ev.pointerId !== activeDrag.pointerId) return;

      const dxTotal = ev.clientX - activeDrag.startX;
      const dyTotal = ev.clientY - activeDrag.startY;
      const dist = Math.hypot(dxTotal, dyTotal);
      if (!activeDrag.dragging && dist >= DRAG_THRESHOLD_PX) {
        activeDrag.dragging = true;
        // Cancel any roll animation while inspecting.
        activeDrag.die.anim = null;
      }

      if (activeDrag.dragging) {
        const dx = ev.clientX - activeDrag.lastX;
        const dy = ev.clientY - activeDrag.lastY;

        // Horizontal drag: spin around world up.
        activeDrag.die.mesh.rotateOnWorldAxis(UP, dx * ROT_SPEED);

        // Vertical drag: tilt around camera-right axis so it feels natural.
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
        activeDrag.die.mesh.rotateOnWorldAxis(right, dy * ROT_SPEED);

        const now = performance.now();
        if ((now - activeDrag.lastSentMs) >= ROT_SEND_INTERVAL_MS) {
          activeDrag.lastSentMs = now;
          postRotate(activeDrag.die.sides, activeDrag.die.mesh.quaternion);
        }
      }

      activeDrag.lastX = ev.clientX;
      activeDrag.lastY = ev.clientY;
      ev.preventDefault();
    });

    function endDrag(ev) {
      if (!activeDrag) return;
      if (ev.pointerId !== activeDrag.pointerId) return;

      const die = activeDrag.die;
      const shouldClick = !activeDrag.dragging;

      try { canvas.releasePointerCapture(ev.pointerId); } catch { }
      activeDrag = null;

      if (shouldClick && die) {
        postDie(die.sides);
      } else if (die) {
        // Send final rotation on drag end.
        postRotate(die.sides, die.mesh.quaternion);
      }

      ev.preventDefault();
    }

    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', endDrag);

    function applyIdlePose(d) {
      d.mesh.rotation.set(0.65, 0.55, 0.08);
      d.anim = null;
      // Preview is not a "settled roll" state, so clear any face-on lock.
      try { delete d.mesh.userData.lockedValue; } catch { d.mesh.userData.lockedValue = undefined; }
      try { delete d.mesh.userData.lockedUWorld; } catch { d.mesh.userData.lockedUWorld = undefined; }
    }

    const UP = new THREE.Vector3(0, 1, 0);
    const _tmpCamDir = new THREE.Vector3();
    const _tmpUp = new THREE.Vector3();
    const _tmpV1 = new THREE.Vector3();
    const _tmpV2 = new THREE.Vector3();
    const _tmpV3 = new THREE.Vector3();
    const _tmpQ = new THREE.Quaternion();

    function quaternionForValue(mesh, value) {
      const frames = mesh.userData.valueToFrame;
      const normals = mesh.userData.valueToNormal;

      const frame = frames && frames.get ? frames.get(value) : null;
      const n = frame?.normal || (normals && normals.get ? normals.get(value) : null);
      if (!n) return null;

      // Target normal: aim at the camera along the view ray for THIS die.
      // In a perspective camera, using camera forward can look "not quite flat" for off-center objects.
      _tmpCamDir.copy(camera.position).sub(mesh.position);
      if (_tmpCamDir.lengthSq() < 1e-8) {
        _tmpCamDir.copy(UP);
      }
      _tmpCamDir.normalize();

      // First rotate the face normal to the target normal.
      const q1 = _tmpQ.setFromUnitVectors(n.clone().normalize(), _tmpCamDir);

      // If we have a stable in-face tangent, add a deterministic twist so the face is upright.
      if (frame && frame.u) {
        // Camera up in world space.
        _tmpUp.set(0, 1, 0).applyQuaternion(camera.quaternion).normalize();

        // Project desired up onto the face plane.
        const targetUp = _tmpV1.copy(_tmpUp).sub(_tmpCamDir.clone().multiplyScalar(_tmpUp.dot(_tmpCamDir)));
        if (targetUp.lengthSq() > 1e-8) {
          targetUp.normalize();

          // Current face-U in world space after q1.
          const uWorld = _tmpV2.copy(frame.u).applyQuaternion(q1);
          const uProj = _tmpV3.copy(uWorld).sub(_tmpCamDir.clone().multiplyScalar(uWorld.dot(_tmpCamDir)));
          if (uProj.lengthSq() > 1e-8) {
            uProj.normalize();

            // Signed angle from uProj -> targetUp around _tmpCamDir.
            const cross = uProj.clone().cross(targetUp);
            const sin = cross.dot(_tmpCamDir);
            const cos = Math.max(-1, Math.min(1, uProj.dot(targetUp)));
            const angle = Math.atan2(sin, cos);

            const qTwist = new THREE.Quaternion().setFromAxisAngle(_tmpCamDir, angle);
            // Apply twist in world space: q = qTwist * q1
            return q1.premultiply(qTwist);
          }
        }
      }

      return q1;
    }

    // Align the chosen face to the camera ray (flat), while preserving a previously-captured
    // in-face direction (so we don't "snap" to an upright printed orientation).
    function quaternionForValuePreserveTwist(mesh, value, desiredUWorld) {
      const frames = mesh.userData.valueToFrame;
      const normals = mesh.userData.valueToNormal;

      const frame = frames && frames.get ? frames.get(value) : null;
      const n = frame?.normal || (normals && normals.get ? normals.get(value) : null);
      if (!n) return null;

      _tmpCamDir.copy(camera.position).sub(mesh.position);
      if (_tmpCamDir.lengthSq() < 1e-8) {
        _tmpCamDir.copy(UP);
      }
      _tmpCamDir.normalize();

      const q1 = _tmpQ.setFromUnitVectors(n.clone().normalize(), _tmpCamDir);
      if (frame && frame.u && desiredUWorld && desiredUWorld.isVector3) {
        const targetUProj = _tmpV1.copy(desiredUWorld).sub(_tmpCamDir.clone().multiplyScalar(desiredUWorld.dot(_tmpCamDir)));
        if (targetUProj.lengthSq() > 1e-8) {
          targetUProj.normalize();

          const uWorld = _tmpV2.copy(frame.u).applyQuaternion(q1);
          const uProj = _tmpV3.copy(uWorld).sub(_tmpCamDir.clone().multiplyScalar(uWorld.dot(_tmpCamDir)));
          if (uProj.lengthSq() > 1e-8) {
            uProj.normalize();

            const cross = uProj.clone().cross(targetUProj);
            const sin = cross.dot(_tmpCamDir);
            const cos = Math.max(-1, Math.min(1, uProj.dot(targetUProj)));
            const angle = Math.atan2(sin, cos);

            const qTwist = new THREE.Quaternion().setFromAxisAngle(_tmpCamDir, angle);
            return q1.premultiply(qTwist);
          }
        }
      }

      return q1;
    }

    // Capture the current in-face direction for this value (projected to the camera plane).
    // We store this and reuse it so the final landing preserves the current twist.
    function computeLockedUWorld(mesh, value) {
      const frames = mesh.userData.valueToFrame;
      const frame = frames && frames.get ? frames.get(value) : null;
      if (!frame || !frame.u) return null;

      _tmpCamDir.copy(camera.position).sub(mesh.position);
      if (_tmpCamDir.lengthSq() < 1e-8) {
        _tmpCamDir.copy(UP);
      }
      _tmpCamDir.normalize();

      const uWorld = _tmpV1.copy(frame.u).applyQuaternion(mesh.quaternion);
      const uProj = _tmpV2.copy(uWorld).sub(_tmpCamDir.clone().multiplyScalar(uWorld.dot(_tmpCamDir)));
      if (uProj.lengthSq() < 1e-8) return null;
      uProj.normalize();
      return uProj.clone();
    }

    function kickRollToValue(d, value) {
      const seed = (d.sides * 1000) + (value * 17);
      const r1 = prng(seed + 1);
      const r2 = prng(seed + 2);
      const r3 = prng(seed + 3);
      const r4 = prng(seed + 4);
      const r5 = prng(seed + 5);
      const r6 = prng(seed + 6);

      const startQ = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(r1 * Math.PI * 2, r2 * Math.PI * 2, r3 * Math.PI * 2)
      );
      d.mesh.quaternion.copy(startQ);

      // Roll lane bounds in the camera-facing plane so dice keep a fixed distance from the screen.
      // (No perspective size changes from moving toward/away from the camera.)
      const uv = { u: 0, v: 0 };
      rollPlaneUVAtNdc(-1, 0, uv);
      const laneInset = 0.6 * DICE_SCALE;
      const uLeft = uv.u + laneInset;
      rollPlaneUVAtNdc(1, 0, uv);
      const uRight = uv.u - laneInset;
      rollPlaneUVAtNdc(0, -1, uv);
      const vMin0 = uv.v + laneInset;
      rollPlaneUVAtNdc(0, 1, uv);
      const vMax0 = uv.v - laneInset;
      const vMin = Math.min(vMin0, vMax0);
      const vMax = Math.max(vMin0, vMax0);

      // Start left and roll across the "table". Use friction-like deceleration and bounce
      // off side walls (left/right) if we hit them.
      const inst = (d.mesh.userData && Number.isFinite(d.mesh.userData.instanceId)) ? d.mesh.userData.instanceId : 0;
      const rV = prng(seed + 77 + inst * 13);
      const startU = uLeft;
      const startV = vMin + (vMax - vMin) * rV;
      const laneW = Math.max(0.001, uRight - uLeft);
      const a = 9.0; // units/s^2 (speed bleed)
      const aApproach = 18.0; // stronger damping once we're on/near the correct face

      // Pick a speed that will usually reach the right wall and bounce at least once.
      // If unbounded, stopping distance would be v0^2/(2a). Use ~1.6x lane width.
      const v0 = Math.sqrt(2 * a * laneW * 1.6);
      const restitution = 0.55 + 0.15 * r4; // energy kept on bounce

      const rad = (d.mesh.userData && Number.isFinite(d.mesh.userData.radius)) ? d.mesh.userData.radius : 0.85;

      // Deterministic tumble axis (so portal/control look the same).
      const tumbleAxis = new THREE.Vector3(r4 - 0.5, r5 - 0.5, r6 - 0.5);
      if (tumbleAxis.lengthSq() < 1e-6) tumbleAxis.set(1, 0.3, 0.2);
      tumbleAxis.normalize();

      // Randomize incoming direction within +/-30 degrees (still left->right overall).
      const maxAngle = 30 * (Math.PI / 180);
      const theta = (r2 * 2 - 1) * maxAngle;
      const vu0 = v0 * Math.cos(theta);
      const vv0 = v0 * Math.sin(theta);

      // Place the die on the roll plane at (uLeft, v=0).
      _tmpPos.copy(_rollPlanePoint)
        .addScaledVector(_rollPlaneRight, startU)
        .addScaledVector(_rollPlaneUp, startV);
      d.mesh.position.copy(_tmpPos);

      // IMPORTANT: the exact face-on alignment depends on the die position (perspective).
      // We will recompute this again right before settling, but initialize it here too.
      const targetQ = quaternionForValue(d.mesh, value);

      // Track which value this die is rolling/settling to so we can keep it face-on later.
      d.mesh.userData.lockedValue = value;
      d.anim = {
        type: 'physicsRoll',
        value,
        t: 0,
        approach: false,
        a,
        aApproach,
        vu: vu0,
        vv: vv0,
        u: startU,
        v: startV,
        uLeft,
        uRight,
        vMin,
        vMax,
        planePoint: _rollPlanePoint.clone(),
        planeNormal: _rollPlaneNormal.clone(),
        planeRight: _rollPlaneRight.clone(),
        planeUp: _rollPlaneUp.clone(),
        restitution,
        rad,
        tumbleAxis,
        startQ,
        targetQ: (targetQ ? targetQ.clone() : new THREE.Quaternion().setFromEuler(new THREE.Euler(0.65, 0.55, 0.08))),
        restTime: 0,
      };
    }

    function valueFacingCamera(mesh) {
      const normals = mesh.userData.valueToNormal;
      if (!normals || !normals.forEach) return null;

      _tmpCamDir.copy(camera.position).sub(mesh.position);
      if (_tmpCamDir.lengthSq() < 1e-8) {
        _tmpCamDir.copy(UP);
      }
      _tmpCamDir.normalize();

      let bestVal = null;
      let bestDot = -Infinity;
      normals.forEach((n, val) => {
        if (!n) return;
        const wn = n.clone().applyQuaternion(mesh.quaternion).normalize();
        const dot = wn.dot(_tmpCamDir);
        if (dot > bestDot) {
          bestDot = dot;
          bestVal = val;
        }
      });

      return bestVal;
    }

    function kickRandomRoll(d, requestId) {
      const seed = (Number(requestId) * 10007) + (d.sides * 97);
      const r1 = prng(seed + 1);
      const r2 = prng(seed + 2);
      const r3 = prng(seed + 3);
      const r4 = prng(seed + 4);
      const r5 = prng(seed + 5);
      const r6 = prng(seed + 6);

      const startQ = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(r1 * Math.PI * 2, r2 * Math.PI * 2, r3 * Math.PI * 2)
      );
      d.mesh.quaternion.copy(startQ);

      // Roll lane bounds in the camera-facing plane so dice keep a fixed distance from the screen.
      const uv = { u: 0, v: 0 };
      rollPlaneUVAtNdc(-1, 0, uv);
      const laneInset = 0.6 * DICE_SCALE;
      const uLeft = uv.u + laneInset;
      rollPlaneUVAtNdc(1, 0, uv);
      const uRight = uv.u - laneInset;
      rollPlaneUVAtNdc(0, -1, uv);
      const vMin0 = uv.v + laneInset;
      rollPlaneUVAtNdc(0, 1, uv);
      const vMax0 = uv.v - laneInset;
      const vMin = Math.min(vMin0, vMax0);
      const vMax = Math.max(vMin0, vMax0);

      const inst = (d.mesh.userData && Number.isFinite(d.mesh.userData.instanceId)) ? d.mesh.userData.instanceId : 0;
      const rv = prng(seed + 99 + inst * 11);
      const startU = uLeft;
      const startV = vMin + (vMax - vMin) * rv;
      const laneW = Math.max(0.001, uRight - uLeft);
      const a = 9.0;
      const aApproach = 18.0;

      const v0 = Math.sqrt(2 * a * laneW * 1.6);
      const restitution = 0.55 + 0.15 * r4;
      const rad = (d.mesh.userData && Number.isFinite(d.mesh.userData.radius)) ? d.mesh.userData.radius : 0.85;

      const tumbleAxis = new THREE.Vector3(r4 - 0.5, r5 - 0.5, r6 - 0.5);
      if (tumbleAxis.lengthSq() < 1e-6) tumbleAxis.set(1, 0.3, 0.2);
      tumbleAxis.normalize();

      const maxAngle = 30 * (Math.PI / 180);
      const theta = (r2 * 2 - 1) * maxAngle;
      const vu0 = v0 * Math.cos(theta);
      const vv0 = v0 * Math.sin(theta);

      _tmpPos.copy(_rollPlanePoint)
        .addScaledVector(_rollPlaneRight, startU)
        .addScaledVector(_rollPlaneUp, startV);
      d.mesh.position.copy(_tmpPos);

      // Random roll duration (seconds) before we pick whatever face is currently up/front.
      const stopAfter = 0.9 + 0.8 * r1;

      // Ensure this die isn't forced to any face during the roll.
      try { delete d.mesh.userData.lockedValue; } catch { d.mesh.userData.lockedValue = undefined; }

      d.anim = {
        type: 'physicsRandom',
        requestId,
        t: 0,
        stopAfter,
        a,
        aApproach,
        vu: vu0,
        vv: vv0,
        u: startU,
        v: startV,
        uLeft,
        uRight,
        vMin,
        vMax,
        planePoint: _rollPlanePoint.clone(),
        planeNormal: _rollPlaneNormal.clone(),
        planeRight: _rollPlaneRight.clone(),
        planeUp: _rollPlaneUp.clone(),
        restitution,
        rad,
        tumbleAxis,
        startQ,
        restTime: 0,
      };
    }

    function setPreview() {
      // User request: don't show any dice until explicitly requested.
      clearAllDice();
    }

    function showRollResults(items) {
      // items: [{sides,value}]
      // Deterministic rolls replace the current set.
      clearAllDice();

      const list = Array.isArray(items) ? items : [];
      for (let i = 0; i < list.length && i < 20; i++) {
        const it = list[i];
        const s = Number(it.sides);
        let v = Number(it.value);
        if (!Number.isFinite(s) || !Number.isFinite(v)) continue;

        // d10 may come through as 0 (meaning 10) depending on upstream formatting.
        if (s === 10 && v === 0) v = 10;
        if (s < 2 || s > 100) continue;
        if (v < 1 || v > s) continue;

        const d = spawnDie(s);
        if (!d) continue;
        kickRollToValue(d, v);
      }
    }

    // Messages from host (C#): {type:'preview'} or {type:'roll', dice:[{sides,value}]}
    if (window.chrome && window.chrome.webview) {
      window.chrome.webview.addEventListener('message', (ev) => {
        try {
          const msg = typeof ev.data === 'string' ? JSON.parse(ev.data) : ev.data;
          if (!msg || !msg.type) return;
          if (msg.type === 'preview') setPreview();
          if (msg.type === 'roll') showRollResults(msg.dice || []);
          if (msg.type === 'rollRandom') {
            const requestId = Number(msg.requestId);
            const sides = Number(msg.sides);
            if (!Number.isFinite(requestId) || requestId <= 0) return;
            if (!Number.isFinite(sides) || sides < 2 || sides > 100) return;
            const d = spawnDie(sides);
            if (!d) return;
            kickRandomRoll(d, requestId);
            // Hide the old stage dice (if present) now that we're showing 3D dice.
          }
          if (msg.type === 'clearAll') {
            clearAllDice();
            return;
          }
          if (msg.type === 'setRotation') {
            const sides = Number(msg.sides);
            const q = msg.q;
            if (!Number.isFinite(sides) || !Array.isArray(q) || q.length !== 4) return;
            const d = findLastDieBySides(sides);
            if (!d) return;
            const x = Number(q[0]);
            const y = Number(q[1]);
            const z = Number(q[2]);
            const w = Number(q[3]);
            if (![x, y, z, w].every(Number.isFinite)) return;
            d.anim = null;
            d.mesh.quaternion.set(x, y, z, w).normalize();
            // If something external is setting rotation, don't force a face-on lock.
            try { delete d.mesh.userData.lockedValue; } catch { d.mesh.userData.lockedValue = undefined; }
            try { delete d.mesh.userData.lockedUWorld; } catch { d.mesh.userData.lockedUWorld = undefined; }
          }
        } catch { }
      });
    }

    // Default: no dice until explicitly requested.

    let t0 = performance.now();
    function animate() {
      const t = performance.now();
      const dt = (t - t0) / 1000;
      t0 = t;

      updateRollPlaneBasis();

      for (const d of dice) {
        if (d.anim) {
          if (d.anim.type === 'physicsRoll') {
            d.anim.t += dt;
            // Integrate velocity on the roll plane with simple kinetic friction (bleed speed magnitude).
            const speed0 = Math.hypot(d.anim.vu, d.anim.vv);
            const aEff = d.anim.approach ? (d.anim.aApproach ?? d.anim.a) : d.anim.a;
            let speed1 = Math.max(0, speed0 - aEff * dt);
            if (speed0 > 1e-6) {
              const s = speed1 / speed0;
              d.anim.vu *= s;
              d.anim.vv *= s;
            } else {
              d.anim.vu = 0;
              d.anim.vv = 0;
            }

            d.anim.u += d.anim.vu * dt;
            d.anim.v += d.anim.vv * dt;

            // Bounce off bounds in plane coordinates.
            let bounced = false;
            if (d.anim.u >= d.anim.uRight) {
              d.anim.u = d.anim.uRight;
              d.anim.vu = -Math.abs(d.anim.vu) * d.anim.restitution;
              bounced = true;
            } else if (d.anim.u <= d.anim.uLeft) {
              d.anim.u = d.anim.uLeft;
              d.anim.vu = Math.abs(d.anim.vu) * d.anim.restitution;
              bounced = true;
            }
            if (d.anim.v >= d.anim.vMax) {
              d.anim.v = d.anim.vMax;
              d.anim.vv = -Math.abs(d.anim.vv) * d.anim.restitution;
              bounced = true;
            } else if (d.anim.v <= d.anim.vMin) {
              d.anim.v = d.anim.vMin;
              d.anim.vv = Math.abs(d.anim.vv) * d.anim.restitution;
              bounced = true;
            }

            // Die-to-die collisions: bounce off other dice on the lane.
            for (const other of dice) {
              if (other === d) continue;
              const r1 = d.anim.rad;
              const r2 = (other.mesh.userData && Number.isFinite(other.mesh.userData.radius)) ? other.mesh.userData.radius : 0.85;

              // Other die's plane coordinates (even if idle, it's on the same roll plane).
              _tmpRel.copy(other.mesh.position).sub(d.anim.planePoint);
              const ou = _tmpRel.dot(d.anim.planeRight);
              const ov = _tmpRel.dot(d.anim.planeUp);

              const du = d.anim.u - ou;
              const dv = d.anim.v - ov;
              const dist = Math.hypot(du, dv);
              const minDist = Math.max(0.001, r1 + r2);
              if (dist >= minDist) continue;

              // Separate (treat the other die as static unless it's also rolling).
              const nx = dist > 1e-6 ? (du / dist) : 1;
              const nz = dist > 1e-6 ? (dv / dist) : 0;
              const pen = (minDist - dist) + 1e-3;

              // Dice that get hit should slide, but not rotate (so they keep their rolled face).
              const otherMoving = other.anim && (other.anim.type === 'physicsRoll' || other.anim.type === 'slide' || other.anim.type === 'physicsRandom' || other.anim.type === 'tip');
              if (!otherMoving) {
                other.anim = {
                  type: 'slide',
                  t: 0,
                  a: d.anim.a,
                  vu: 0,
                  vv: 0,
                  u: ou,
                  v: ov,
                  uLeft: d.anim.uLeft,
                  uRight: d.anim.uRight,
                  vMin: d.anim.vMin,
                  vMax: d.anim.vMax,
                  restitution: d.anim.restitution,
                  rad: r2,
                  planePoint: d.anim.planePoint,
                  planeNormal: d.anim.planeNormal,
                  planeRight: d.anim.planeRight,
                  planeUp: d.anim.planeUp,
                  fixedQ: other.mesh.quaternion.clone(),
                  restTime: 0,
                };
              }

              const otherDyn = other.anim && (other.anim.type === 'physicsRoll' || other.anim.type === 'slide' || other.anim.type === 'physicsRandom' || other.anim.type === 'tip') ? other.anim : null;
              if (!otherDyn) continue;

              // Separate both dice in-plane.
              d.anim.u += nx * (pen * 0.5);
              d.anim.v += nz * (pen * 0.5);
              otherDyn.u -= nx * (pen * 0.5);
              otherDyn.v -= nz * (pen * 0.5);

              // Apply immediately to keep both dice on the same plane.
              other.mesh.position.copy(otherDyn.planePoint)
                .addScaledVector(otherDyn.planeRight, otherDyn.u)
                .addScaledVector(otherDyn.planeUp, otherDyn.v);

              // Compute bounce response along collision normal.
              const e = Math.min(d.anim.restitution, otherDyn.restitution ?? d.anim.restitution);
              const ovu = Number.isFinite(otherDyn.vu) ? otherDyn.vu : 0;
              const ovv = Number.isFinite(otherDyn.vv) ? otherDyn.vv : 0;
              const rvx = d.anim.vu - ovu;
              const rvz = d.anim.vv - ovv;
              const rel = rvx * nx + rvz * nz;
              if (rel < 0) {
                const j = -(1 + e) * rel / 2; // equal mass
                d.anim.vu += j * nx;
                d.anim.vv += j * nz;
                otherDyn.vu -= j * nx;
                otherDyn.vv -= j * nz;
                bounced = true;
              }
            }

            // Convert plane coordinates back to world position (constant distance from screen).
            d.mesh.position.copy(d.anim.planePoint)
              .addScaledVector(d.anim.planeRight, d.anim.u)
              .addScaledVector(d.anim.planeUp, d.anim.v);

            // Rolling: primary rotation proportional to speed, axis derived from travel direction.
            const speed = Math.hypot(d.anim.vu, d.anim.vv);
            const omega = (speed / Math.max(0.001, d.anim.rad));
            const dTheta = omega * dt;
            if (speed > 1e-6) {
              _tmpTravel.copy(d.anim.planeRight).multiplyScalar(d.anim.vu)
                .addScaledVector(d.anim.planeUp, d.anim.vv)
                .normalize();
              _tmpRollAxis.copy(d.anim.planeNormal).cross(_tmpTravel);
              if (_tmpRollAxis.lengthSq() > 1e-6) {
                _tmpRollAxis.normalize();
                d.mesh.rotateOnWorldAxis(_tmpRollAxis, dTheta);
              }
            }
            const alignStartSpeed = 1.25;

            // Compute the intended final face pose for THIS position (perspective-correct)
            // and measure angular error.
            let qTargetNow = null;
            let angErr = Math.PI;
            {
              const v = Number.isFinite(d.anim.value) ? d.anim.value : null;
              qTargetNow = v ? quaternionForValue(d.mesh, v) : null;
              if (qTargetNow) {
                d.anim.targetQ.copy(qTargetNow);
                const dot = Math.abs(d.mesh.quaternion.dot(qTargetNow));
                const clamped = Math.max(-1, Math.min(1, dot));
                angErr = 2 * Math.acos(clamped);
              }
            }

            // Enter approach ONLY when we're already on/near the correct face.
            // (This avoids the visible "snap" from forcibly steering rotation.)
            const approachAngle = 10 * (Math.PI / 180);
            const minFreeT = 0.20;
            if (!d.anim.approach && d.anim.t >= minFreeT && angErr <= approachAngle) {
              d.anim.approach = true;
            }

            // Reduce extra tumble during approach so the die naturally settles.
            const tumbleScale = d.anim.approach
              ? 0.15 * Math.max(0.0, Math.min(1.0, speed / alignStartSpeed))
              : Math.max(0.0, Math.min(1.0, speed / alignStartSpeed));
            d.mesh.rotateOnWorldAxis(d.anim.tumbleAxis, dTheta * 0.65 * tumbleScale);

            // Add a small extra tumble impulse on bounce so it feels less "linear".
            if (bounced) {
              const bump = 0.18;
              d.mesh.rotateOnWorldAxis(d.anim.tumbleAxis, (Math.random() - 0.5) * bump);
            }

            // No forced steering toward the target face here.
            // We let the die keep rolling until it naturally reaches the right face.

            // Transition to a deterministic "tip" (land on the correct face) once we slow down
            // or after a timeout. This guarantees we don't roll forever and gives a visible
            // "tip and land" finish.
            const tipStartSpeed = 0.55;
            const tipLeadSeconds = 1.50;
            const forceTipT = 2.25;
            {
              const aEffNow = d.anim.approach ? (d.anim.aApproach ?? d.anim.a) : d.anim.a;
              const tToStop = speed / Math.max(0.001, aEffNow);
              const okToTipEarly = (d.anim.approach || angErr <= (1.5 * approachAngle));
              const shouldTip = (speed <= tipStartSpeed) || (okToTipEarly && tToStop <= tipLeadSeconds);
              if (d.anim.t >= minFreeT && (shouldTip || d.anim.t >= forceTipT)) {
              const v = Number.isFinite(d.anim.value) ? d.anim.value : null;

              // Preserve the current printed twist (no upright snap) while landing flat.
              let lockedU = null;
              if (v != null) {
                lockedU = computeLockedUWorld(d.mesh, v);
                if (lockedU) {
                  d.mesh.userData.lockedUWorld = lockedU;
                } else {
                  try { delete d.mesh.userData.lockedUWorld; } catch { d.mesh.userData.lockedUWorld = undefined; }
                }
              }

              const qTip = (
                (v ? (lockedU ? quaternionForValuePreserveTwist(d.mesh, v, lockedU) : quaternionForValuePreserveTwist(d.mesh, v, null)) : null)
                || qTargetNow
                || (v ? quaternionForValue(d.mesh, v) : null)
                || d.anim.targetQ
              ).clone();

              // Add a subtle per-die rock axis for the final landing.
              // Keep it in the roll plane so it reads as a physical tilt/rock.
              let rockAxis = null;
              {
                const id = (d.mesh.userData && Number.isFinite(d.mesh.userData.instanceId)) ? d.mesh.userData.instanceId : (Math.random() * 1000);
                const s1 = prng(id * 12.9898 + 78.233) < 0.5 ? -1 : 1;
                const s2 = prng(id * 93.9898 + 67.345) < 0.5 ? -1 : 1;
                const axis = new THREE.Vector3()
                  .copy(d.anim.planeRight).multiplyScalar(s1)
                  .addScaledVector(d.anim.planeUp, 0.7 * s2);
                if (axis.lengthSq() > 1e-8) {
                  axis.normalize();
                  rockAxis = axis;
                }
              }

              d.anim = {
                type: 'tip',
                value: d.anim.value,
                t: 0,
                a: d.anim.a,
                aApproach: d.anim.aApproach,
                vu: d.anim.vu,
                vv: d.anim.vv,
                u: d.anim.u,
                v: d.anim.v,
                uLeft: d.anim.uLeft,
                uRight: d.anim.uRight,
                vMin: d.anim.vMin,
                vMax: d.anim.vMax,
                restitution: Math.min(0.25, d.anim.restitution),
                rad: d.anim.rad,
                planePoint: d.anim.planePoint,
                planeNormal: d.anim.planeNormal,
                planeRight: d.anim.planeRight,
                planeUp: d.anim.planeUp,
                fromQ: new THREE.Quaternion().copy(d.mesh.quaternion),
                targetQ: qTip,
                tipDur: 0.52,
                rockAxis,
                rockStart: 0.68,
                rockCycles: 1.6,
                rockAmp: 3.25 * (Math.PI / 180),
                restTime: 0,
              };
              }
            }
          } else if (d.anim.type === 'slide') {
            d.anim.t += dt;

            // Keep the face-on orientation while sliding.
            // This must be recomputed from position (perspective) to stay perfectly flat.
            {
              const v = Number.isFinite(d.mesh.userData.lockedValue) ? d.mesh.userData.lockedValue : null;
              const u = d.mesh.userData.lockedUWorld;
              const qNow = v ? (u ? quaternionForValuePreserveTwist(d.mesh, v, u) : quaternionForValuePreserveTwist(d.mesh, v, null)) : null;
              if (qNow) {
                d.mesh.quaternion.slerp(qNow, slerpEase(d.mesh.quaternion, qNow, dt, 22.0));
              } else if (d.anim.fixedQ) {
                d.mesh.quaternion.copy(d.anim.fixedQ);
              }
            }

            // Integrate velocity on the roll plane with friction.
            const speed0 = Math.hypot(d.anim.vu, d.anim.vv);
            const speed1 = Math.max(0, speed0 - d.anim.a * dt);
            if (speed0 > 1e-6) {
              const s = speed1 / speed0;
              d.anim.vu *= s;
              d.anim.vv *= s;
            } else {
              d.anim.vu = 0;
              d.anim.vv = 0;
            }

            d.anim.u += d.anim.vu * dt;
            d.anim.v += d.anim.vv * dt;

            // Bounce off bounds.
            if (d.anim.u >= d.anim.uRight) {
              d.anim.u = d.anim.uRight;
              d.anim.vu = -Math.abs(d.anim.vu) * d.anim.restitution;
            } else if (d.anim.u <= d.anim.uLeft) {
              d.anim.u = d.anim.uLeft;
              d.anim.vu = Math.abs(d.anim.vu) * d.anim.restitution;
            }
            if (d.anim.v >= d.anim.vMax) {
              d.anim.v = d.anim.vMax;
              d.anim.vv = -Math.abs(d.anim.vv) * d.anim.restitution;
            } else if (d.anim.v <= d.anim.vMin) {
              d.anim.v = d.anim.vMin;
              d.anim.vv = Math.abs(d.anim.vv) * d.anim.restitution;
            }

            // Collide with other dice (can push idle dice into slide, but never rotate them).
            for (const other of dice) {
              if (other === d) continue;
              const r1 = d.anim.rad;
              const r2 = (other.mesh.userData && Number.isFinite(other.mesh.userData.radius)) ? other.mesh.userData.radius : 0.85;

              _tmpRel.copy(other.mesh.position).sub(d.anim.planePoint);
              const ou = _tmpRel.dot(d.anim.planeRight);
              const ov = _tmpRel.dot(d.anim.planeUp);

              const du = d.anim.u - ou;
              const dv = d.anim.v - ov;
              const dist = Math.hypot(du, dv);
              const minDist = Math.max(0.001, r1 + r2);
              if (dist >= minDist) continue;

              const nx = dist > 1e-6 ? (du / dist) : 1;
              const nz = dist > 1e-6 ? (dv / dist) : 0;
              const pen = (minDist - dist) + 1e-3;

              const otherMoving = other.anim && (other.anim.type === 'physicsRoll' || other.anim.type === 'slide' || other.anim.type === 'physicsRandom' || other.anim.type === 'tip');
              if (!otherMoving) {
                other.anim = {
                  type: 'slide',
                  t: 0,
                  a: d.anim.a,
                  vu: 0,
                  vv: 0,
                  u: ou,
                  v: ov,
                  uLeft: d.anim.uLeft,
                  uRight: d.anim.uRight,
                  vMin: d.anim.vMin,
                  vMax: d.anim.vMax,
                  restitution: d.anim.restitution,
                  rad: r2,
                  planePoint: d.anim.planePoint,
                  planeNormal: d.anim.planeNormal,
                  planeRight: d.anim.planeRight,
                  planeUp: d.anim.planeUp,
                  fixedQ: other.mesh.quaternion.clone(),
                  restTime: 0,
                };
              }

              const otherDyn = other.anim && (other.anim.type === 'physicsRoll' || other.anim.type === 'slide' || other.anim.type === 'physicsRandom' || other.anim.type === 'tip') ? other.anim : null;
              if (!otherDyn) continue;

              d.anim.u += nx * (pen * 0.5);
              d.anim.v += nz * (pen * 0.5);
              otherDyn.u -= nx * (pen * 0.5);
              otherDyn.v -= nz * (pen * 0.5);

              other.mesh.position.copy(otherDyn.planePoint)
                .addScaledVector(otherDyn.planeRight, otherDyn.u)
                .addScaledVector(otherDyn.planeUp, otherDyn.v);

              const e = Math.min(d.anim.restitution, otherDyn.restitution ?? d.anim.restitution);
              const ovu = Number.isFinite(otherDyn.vu) ? otherDyn.vu : 0;
              const ovv = Number.isFinite(otherDyn.vv) ? otherDyn.vv : 0;
              const rvx = d.anim.vu - ovu;
              const rvz = d.anim.vv - ovv;
              const rel = rvx * nx + rvz * nz;
              if (rel < 0) {
                const j = -(1 + e) * rel / 2;
                d.anim.vu += j * nx;
                d.anim.vv += j * nz;
                otherDyn.vu -= j * nx;
                otherDyn.vv -= j * nz;
              }
            }

            // Convert plane coordinates back to world position.
            d.mesh.position.copy(d.anim.planePoint)
              .addScaledVector(d.anim.planeRight, d.anim.u)
              .addScaledVector(d.anim.planeUp, d.anim.v);

            // Stop once we've basically stopped for a short moment.
            if (Math.hypot(d.anim.vu, d.anim.vv) < 0.10) {
              d.anim.restTime += dt;
            } else {
              d.anim.restTime = 0;
            }

            if (d.anim.restTime >= 0.12) {
              d.anim = null;
            }
          } else if (d.anim.type === 'physicsRandom') {
            d.anim.t += dt;

            // Same translation physics as physicsRoll.
            const speed0 = Math.hypot(d.anim.vu, d.anim.vv);
            const aEff = d.anim.a;
            const speed1 = Math.max(0, speed0 - aEff * dt);
            if (speed0 > 1e-6) {
              const s = speed1 / speed0;
              d.anim.vu *= s;
              d.anim.vv *= s;
            } else {
              d.anim.vu = 0;
              d.anim.vv = 0;
            }

            d.anim.u += d.anim.vu * dt;
            d.anim.v += d.anim.vv * dt;

            // Bounce off bounds.
            let bounced = false;
            if (d.anim.u >= d.anim.uRight) {
              d.anim.u = d.anim.uRight;
              d.anim.vu = -Math.abs(d.anim.vu) * d.anim.restitution;
              bounced = true;
            } else if (d.anim.u <= d.anim.uLeft) {
              d.anim.u = d.anim.uLeft;
              d.anim.vu = Math.abs(d.anim.vu) * d.anim.restitution;
              bounced = true;
            }
            if (d.anim.v >= d.anim.vMax) {
              d.anim.v = d.anim.vMax;
              d.anim.vv = -Math.abs(d.anim.vv) * d.anim.restitution;
              bounced = true;
            } else if (d.anim.v <= d.anim.vMin) {
              d.anim.v = d.anim.vMin;
              d.anim.vv = Math.abs(d.anim.vv) * d.anim.restitution;
              bounced = true;
            }

            // Die-to-die collisions (same as physicsRoll).
            for (const other of dice) {
              if (other === d) continue;
              const r1 = d.anim.rad;
              const r2 = (other.mesh.userData && Number.isFinite(other.mesh.userData.radius)) ? other.mesh.userData.radius : 0.85;

              _tmpRel.copy(other.mesh.position).sub(d.anim.planePoint);
              const ou = _tmpRel.dot(d.anim.planeRight);
              const ov = _tmpRel.dot(d.anim.planeUp);

              const du = d.anim.u - ou;
              const dv = d.anim.v - ov;
              const dist = Math.hypot(du, dv);
              const minDist = Math.max(0.001, r1 + r2);
              if (dist >= minDist) continue;

              const nx = dist > 1e-6 ? (du / dist) : 1;
              const nz = dist > 1e-6 ? (dv / dist) : 0;
              const pen = (minDist - dist) + 1e-3;

              const otherMoving = other.anim && (other.anim.type === 'physicsRoll' || other.anim.type === 'slide' || other.anim.type === 'physicsRandom' || other.anim.type === 'tip');
              if (!otherMoving) {
                other.anim = {
                  type: 'slide',
                  t: 0,
                  a: d.anim.a,
                  vu: 0,
                  vv: 0,
                  u: ou,
                  v: ov,
                  uLeft: d.anim.uLeft,
                  uRight: d.anim.uRight,
                  vMin: d.anim.vMin,
                  vMax: d.anim.vMax,
                  restitution: d.anim.restitution,
                  rad: r2,
                  planePoint: d.anim.planePoint,
                  planeNormal: d.anim.planeNormal,
                  planeRight: d.anim.planeRight,
                  planeUp: d.anim.planeUp,
                  fixedQ: other.mesh.quaternion.clone(),
                  restTime: 0,
                };
              }

              const otherDyn = other.anim && (other.anim.type === 'physicsRoll' || other.anim.type === 'slide' || other.anim.type === 'physicsRandom') ? other.anim : null;
              if (!otherDyn) continue;

              d.anim.u += nx * (pen * 0.5);
              d.anim.v += nz * (pen * 0.5);
              otherDyn.u -= nx * (pen * 0.5);
              otherDyn.v -= nz * (pen * 0.5);

              other.mesh.position.copy(otherDyn.planePoint)
                .addScaledVector(otherDyn.planeRight, otherDyn.u)
                .addScaledVector(otherDyn.planeUp, otherDyn.v);

              const e = Math.min(d.anim.restitution, otherDyn.restitution ?? d.anim.restitution);
              const ovu = Number.isFinite(otherDyn.vu) ? otherDyn.vu : 0;
              const ovv = Number.isFinite(otherDyn.vv) ? otherDyn.vv : 0;
              const rvx = d.anim.vu - ovu;
              const rvz = d.anim.vv - ovv;
              const rel = rvx * nx + rvz * nz;
              if (rel < 0) {
                const j = -(1 + e) * rel / 2;
                d.anim.vu += j * nx;
                d.anim.vv += j * nz;
                otherDyn.vu -= j * nx;
                otherDyn.vv -= j * nz;
                bounced = true;
              }
            }

            d.mesh.position.copy(d.anim.planePoint)
              .addScaledVector(d.anim.planeRight, d.anim.u)
              .addScaledVector(d.anim.planeUp, d.anim.v);

            // Rotation from travel direction (plus some tumble).
            const speed = Math.hypot(d.anim.vu, d.anim.vv);
            const omega = (speed / Math.max(0.001, d.anim.rad));
            const dTheta = omega * dt;
            if (speed > 1e-6) {
              _tmpTravel.copy(d.anim.planeRight).multiplyScalar(d.anim.vu)
                .addScaledVector(d.anim.planeUp, d.anim.vv)
                .normalize();
              _tmpRollAxis.copy(d.anim.planeNormal).cross(_tmpTravel);
              if (_tmpRollAxis.lengthSq() > 1e-6) {
                _tmpRollAxis.normalize();
                d.mesh.rotateOnWorldAxis(_tmpRollAxis, dTheta);
              }
            }
            d.mesh.rotateOnWorldAxis(d.anim.tumbleAxis, dTheta * 0.55);
            if (bounced) {
              const bump = 0.18;
              d.mesh.rotateOnWorldAxis(d.anim.tumbleAxis, (Math.random() - 0.5) * bump);
            }

            // After a random amount of time, pick whichever face is currently facing the camera
            // and "tip" to land on it.
            const tipStartSpeed = 0.55;
            const tipLeadSeconds = 1.50;
            const forceTipT = Math.max(d.anim.stopAfter + 0.85, 2.65);
            {
              const aEffNow = d.anim.approach ? (d.anim.aApproach ?? d.anim.a) : d.anim.a;
              const tToStop = speed / Math.max(0.001, aEffNow);
              const shouldTip = (speed <= tipStartSpeed) || (tToStop <= tipLeadSeconds);
              if ((d.anim.t >= d.anim.stopAfter && shouldTip) || d.anim.t >= forceTipT) {
              const chosen = valueFacingCamera(d.mesh);
              const v = Number.isFinite(chosen) ? chosen : 1;
              d.mesh.userData.lockedValue = v;
              // Preserve whatever "printed" twist we ended with (no upright snap),
              // but still land flat to the camera.
              const lockedU = computeLockedUWorld(d.mesh, v);
              if (lockedU) {
                d.mesh.userData.lockedUWorld = lockedU;
              } else {
                try { delete d.mesh.userData.lockedUWorld; } catch { d.mesh.userData.lockedUWorld = undefined; }
              }

              const qTip = quaternionForValuePreserveTwist(d.mesh, v, lockedU) || new THREE.Quaternion().copy(d.mesh.quaternion);

              // Add a subtle per-die rock axis for the final landing.
              let rockAxis = null;
              {
                const id = (d.mesh.userData && Number.isFinite(d.mesh.userData.instanceId)) ? d.mesh.userData.instanceId : (Math.random() * 1000);
                const s1 = prng(id * 12.9898 + 78.233) < 0.5 ? -1 : 1;
                const s2 = prng(id * 93.9898 + 67.345) < 0.5 ? -1 : 1;
                const axis = new THREE.Vector3()
                  .copy(d.anim.planeRight).multiplyScalar(s1)
                  .addScaledVector(d.anim.planeUp, 0.7 * s2);
                if (axis.lengthSq() > 1e-8) {
                  axis.normalize();
                  rockAxis = axis;
                }
              }

              d.anim = {
                type: 'tip',
                requestId: d.anim.requestId,
                value: v,
                t: 0,
                a: d.anim.a,
                aApproach: d.anim.aApproach,
                vu: d.anim.vu,
                vv: d.anim.vv,
                u: d.anim.u,
                v: d.anim.v,
                uLeft: d.anim.uLeft,
                uRight: d.anim.uRight,
                vMin: d.anim.vMin,
                vMax: d.anim.vMax,
                restitution: Math.min(0.25, d.anim.restitution),
                rad: d.anim.rad,
                planePoint: d.anim.planePoint,
                planeNormal: d.anim.planeNormal,
                planeRight: d.anim.planeRight,
                planeUp: d.anim.planeUp,
                fromQ: new THREE.Quaternion().copy(d.mesh.quaternion),
                targetQ: qTip.clone(),
                tipDur: 0.52,
                rockAxis,
                rockStart: 0.68,
                rockCycles: 1.6,
                rockAmp: 3.25 * (Math.PI / 180),
                restTime: 0,
              };
              }
            }
          } else if (d.anim.type === 'tip') {
            d.anim.t += dt;

            // Keep this pose perspective-correct as we move slightly.
            const v = Number.isFinite(d.anim.value) ? d.anim.value : null;
            const u = d.mesh.userData.lockedUWorld;
            const qTargetNow = v ? (u ? quaternionForValuePreserveTwist(d.mesh, v, u) : quaternionForValuePreserveTwist(d.mesh, v, null)) : null;
            if (qTargetNow) {
              d.anim.targetQ.copy(qTargetNow);
            }

            // Strong damping to a stop (still allows a little slide).
            const speed0 = Math.hypot(d.anim.vu, d.anim.vv);
            const kTrans = 10.0; // 1/s
            const decay = Math.exp(-kTrans * dt);
            d.anim.vu *= decay;
            d.anim.vv *= decay;

            d.anim.u += d.anim.vu * dt;
            d.anim.v += d.anim.vv * dt;

            // Gentle bounce off bounds.
            if (d.anim.u >= d.anim.uRight) {
              d.anim.u = d.anim.uRight;
              d.anim.vu = -Math.abs(d.anim.vu) * d.anim.restitution;
            } else if (d.anim.u <= d.anim.uLeft) {
              d.anim.u = d.anim.uLeft;
              d.anim.vu = Math.abs(d.anim.vu) * d.anim.restitution;
            }
            if (d.anim.v >= d.anim.vMax) {
              d.anim.v = d.anim.vMax;
              d.anim.vv = -Math.abs(d.anim.vv) * d.anim.restitution;
            } else if (d.anim.v <= d.anim.vMin) {
              d.anim.v = d.anim.vMin;
              d.anim.vv = Math.abs(d.anim.vv) * d.anim.restitution;
            }

            // Apply position.
            d.mesh.position.copy(d.anim.planePoint)
              .addScaledVector(d.anim.planeRight, d.anim.u)
              .addScaledVector(d.anim.planeUp, d.anim.v);

            // Rotate toward the target at a bounded angular speed (looks like tipping/landing).
            {
              // Back-compat: older tip objects might not have these.
              if (!d.anim.fromQ) d.anim.fromQ = new THREE.Quaternion().copy(d.mesh.quaternion);
              if (!Number.isFinite(d.anim.tipDur)) d.anim.tipDur = 0.52;
              if (!Number.isFinite(d.anim.rockStart)) d.anim.rockStart = 0.68;
              if (!Number.isFinite(d.anim.rockCycles)) d.anim.rockCycles = 1.6;
              if (!Number.isFinite(d.anim.rockAmp)) d.anim.rockAmp = 3.25 * (Math.PI / 180);

              // Time-based ease-in: slow start, faster fall into final face.
              const uT = Math.max(0, Math.min(1, d.anim.t / Math.max(1e-6, d.anim.tipDur)));
              const s = uT * uT;
              _tmpQ0.slerpQuaternions(d.anim.fromQ, d.anim.targetQ, s);

              // Add a small decaying rock near the end.
              if (d.anim.rockAxis && d.anim.rockAxis.lengthSq && d.anim.rockAxis.lengthSq() > 1e-8) {
                const rs = Math.max(0, Math.min(0.98, d.anim.rockStart));
                const x = Math.max(0, Math.min(1, (uT - rs) / Math.max(1e-6, 1 - rs)));
                const ramp = x * x * (3 - 2 * x);
                const decay = (1 - x);
                const amp = d.anim.rockAmp * ramp * decay;
                const cycles = d.anim.rockCycles;
                const phase = 2 * Math.PI * cycles * x;
                const rockAngle = amp * Math.sin(phase);

                _tmpQRock.setFromAxisAngle(d.anim.rockAxis, rockAngle);
                _tmpQ1.copy(_tmpQ0).premultiply(_tmpQRock);
                d.mesh.quaternion.copy(_tmpQ1);
              } else {
                d.mesh.quaternion.copy(_tmpQ0);
              }

              const dot = Math.abs(d.mesh.quaternion.dot(d.anim.targetQ));
              const clamped = Math.max(-1, Math.min(1, dot));
              const angErr = 2 * Math.acos(clamped);

              // Finish once we're both very close and basically stopped.
              const speed = Math.hypot(d.anim.vu, d.anim.vv);
              const finishAngle = 0.65 * (Math.PI / 180);
              const finishSpeed = 0.05;
              if (angErr <= finishAngle && speed <= finishSpeed) {
                d.anim.restTime += dt;
              } else {
                d.anim.restTime = 0;
              }

              if (d.anim.restTime >= 0.10) {
                if (Number.isFinite(d.anim.value)) {
                  d.mesh.userData.lockedValue = d.anim.value;
                }

                // If this tip was from a random roll request, report the settled value back to host.
                if (window.chrome && window.chrome.webview && Number.isFinite(d.anim.requestId) && Number.isFinite(d.anim.value)) {
                  try {
                    window.chrome.webview.postMessage(JSON.stringify({
                      type: 'rollResult',
                      requestId: d.anim.requestId,
                      sides: d.sides,
                      value: d.anim.value,
                    }));
                  } catch { }
                }

                d.anim = null;
              }
            }
          } else if (d.anim.type === 'settle') {
            d.anim.settleT += dt;
            const u = Math.min(1, d.anim.settleT / d.anim.settleDur);
            const s = u * u * (3 - 2 * u);
            d.mesh.quaternion.slerpQuaternions(d.anim.settleFromQ, d.anim.targetQ, s);
            if (u >= 1) {
              // Once settled, keep this die face-on forever (even if it gets slid/bumped).
              if (Number.isFinite(d.anim.value)) {
                d.mesh.userData.lockedValue = d.anim.value;
              }
              d.anim = null;
            }
          } else {
            // Back-compat: older animation objects.
            d.anim.t += dt;
            const u = Math.min(1, d.anim.t / d.anim.duration);
            const s = u * u * (3 - 2 * u);
            d.mesh.quaternion.slerpQuaternions(d.anim.start, d.anim.target, s);
            if (u >= 1) d.anim = null;
          }
        }

        d.lines.position.copy(d.mesh.position);
        d.lines.quaternion.copy(d.mesh.quaternion);
      }

      // Prevent dice from ever remaining merged/clipped, even after settling.
      ensureNonOverlapAllDice();

      // Maintain face-on orientation for any die that is "settled" (no active animation)
      // and has a known locked value. This ensures bumps/slides never leave it tilted.
      for (const d of dice) {
        if (!d.anim && Number.isFinite(d.mesh.userData.lockedValue)) {
          const v = d.mesh.userData.lockedValue;
          const u = d.mesh.userData.lockedUWorld;
          const qNow = u ? quaternionForValuePreserveTwist(d.mesh, v, u) : quaternionForValuePreserveTwist(d.mesh, v, null);
          if (qNow) {
            d.mesh.quaternion.slerp(qNow, slerpEase(d.mesh.quaternion, qNow, dt, 18.0));
            d.lines.quaternion.copy(d.mesh.quaternion);
          }
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
