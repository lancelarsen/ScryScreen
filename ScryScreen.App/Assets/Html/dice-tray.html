<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScryScreen Dice Tray</title>
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#0A0F18; }
    #c { display:block; width:100%; height:100%; }
    .hint { position:absolute; left:10px; top:8px; color:#94a3b8; font: 12px/1.2 system-ui, Segoe UI, sans-serif; opacity:0.85; user-select:none; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Click a die: d4 d6 d8 d10 d12 d20</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setClearColor(0x0A0F18, 1);
    renderer.physicallyCorrectLights = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.12;

    const scene = new THREE.Scene();

    // Subtle reflections for all dice (no external assets/imports).
    // We generate a tiny equirectangular "room" gradient, then PMREM it.
    (function setupEnvironment() {
      const w = 64;
      const h = 32;
      const data = new Uint8Array(w * h * 4);

      // Top->bottom gradient: deep blue -> slate -> near-black
      const top = { r: 16, g: 30, b: 56 };
      const mid = { r: 58, g: 66, b: 84 };
      const bot = { r: 6, g: 10, b: 18 };

      for (let y = 0; y < h; y++) {
        const t = y / (h - 1);
        const t2 = Math.min(1, Math.max(0, (t - 0.40) / 0.60));
        const r = Math.round(top.r * (1 - t) + mid.r * t);
        const g = Math.round(top.g * (1 - t) + mid.g * t);
        const b = Math.round(top.b * (1 - t) + mid.b * t);
        const rr = Math.round(r * (1 - t2) + bot.r * t2);
        const gg = Math.round(g * (1 - t2) + bot.g * t2);
        const bb = Math.round(b * (1 - t2) + bot.b * t2);

        for (let x = 0; x < w; x++) {
          // Add a subtle bright "softbox" patch near the top-center so reflections read
          // on flat faces (e.g., d6) as well as many-faced dice (e.g., d10).
          const xn = x / (w - 1);
          const yn = y / (h - 1);
          const cx = 0.5;
          const cy = 0.14;
          const dx = (xn - cx) / 0.35;
          const dy = (yn - cy) / 0.10;
          const softbox = Math.exp(-(dx * dx + dy * dy));
          const boost = 0.55 * softbox;

          const r2 = Math.min(255, Math.round(rr + (255 - rr) * boost));
          const g2 = Math.min(255, Math.round(gg + (255 - gg) * boost));
          const b2 = Math.min(255, Math.round(bb + (255 - bb) * boost));

          const i = (y * w + x) * 4;
          data[i + 0] = r2;
          data[i + 1] = g2;
          data[i + 2] = b2;
          data[i + 3] = 255;
        }
      }

      const tex = new THREE.DataTexture(data, w, h, THREE.RGBAFormat);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.mapping = THREE.EquirectangularReflectionMapping;
      tex.needsUpdate = true;

      const pmrem = new THREE.PMREMGenerator(renderer);
      // IMPORTANT: keep the render target alive; disposing it also disposes the texture.
      const envRT = pmrem.fromEquirectangular(tex);
      scene.environment = envRT.texture;
      tex.dispose();

      // Optional cleanup on page unload.
      window.addEventListener('unload', () => {
        try { envRT.dispose(); } catch { }
        try { pmrem.dispose(); } catch { }
      });
    })();

    // Camera is framed so dice live near the *top* of the view.
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 60);
    camera.position.set(0, 6.0, 11.0);
    camera.lookAt(0, 2.5, 0);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x111827, 0.9);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.3);
    dir.position.set(5, 7, 6);
    scene.add(dir);

    // Add a focused light to create a readable specular highlight on ALL dice.
    // This helps flat-faced dice (like d6) show the same "reflection" as d10.
    const spot = new THREE.SpotLight(0xffffff, 85, 0, Math.PI / 10, 0.25, 1.0);
    spot.position.set(-3.5, 10, 7.5);
    spot.target.position.set(0, 2.1, 0);
    spot.castShadow = false;
    scene.add(spot);
    scene.add(spot.target);

    const floorGeo = new THREE.PlaneGeometry(30, 14);
    const floorMat = new THREE.ShadowMaterial({ opacity: 0.25 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0.0;
    floor.receiveShadow = true;
    scene.add(floor);

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const metal = 0.55;
    const rough = 0.08;
    const baseMat = new THREE.MeshPhysicalMaterial({
      color: 0xf3f4f6,
      metalness: metal,
      roughness: rough,
      envMapIntensity: 2.75,
      clearcoat: 1.0,
      clearcoatRoughness: 0.06,
      ior: 1.5,
      flatShading: true,
    });

    function makeEdges(mesh) {
      const eg = new THREE.EdgesGeometry(mesh.geometry, 25);
      const lm = new THREE.LineBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.8 });
      const lines = new THREE.LineSegments(eg, lm);
      lines.position.copy(mesh.position);
      lines.quaternion.copy(mesh.quaternion);
      lines.scale.copy(mesh.scale);
      return lines;
    }

    function ensureOutwardWinding(geometry) {
      // Fixes triangle winding so faces render with FrontSide materials.
      // For convex polyhedra centered at origin, outward normals satisfy normal·centroid > 0.
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      if (!pos || !index) return;

      const a = new THREE.Vector3();
      const b = new THREE.Vector3();
      const c = new THREE.Vector3();
      const ab = new THREE.Vector3();
      const ac = new THREE.Vector3();
      const n = new THREE.Vector3();
      const centroid = new THREE.Vector3();

      for (let i = 0; i < index.count; i += 3) {
        const ia = index.getX(i);
        const ib = index.getX(i + 1);
        const ic = index.getX(i + 2);
        a.fromBufferAttribute(pos, ia);
        b.fromBufferAttribute(pos, ib);
        c.fromBufferAttribute(pos, ic);

        ab.copy(b).sub(a);
        ac.copy(c).sub(a);
        n.copy(ab).cross(ac);
        centroid.copy(a).add(b).add(c).multiplyScalar(1 / 3);

        if (n.dot(centroid) < 0) {
          // Swap winding
          index.setX(i + 1, ic);
          index.setX(i + 2, ib);
        }
      }

      index.needsUpdate = true;
    }

    // D10: pentagonal trapezohedron built as indexed triangles.
    // Important: the two triangles that make each kite must be coplanar, otherwise
    // EdgesGeometry will show the diagonal and the shape looks "broken".
    function createD10Geometry(radius = 0.86) {
      const n = 5;

      // Planarity constraint for this construction: apexDistance / ringPlaneOffset ≈ 9.472135955
      const apexToPlane = 9.47213595499958;

      const apexY = radius * 0.90;
      const ringY = apexY / apexToPlane;
      const r = radius * 0.82;

      // Vertex layout (Y-up):
      // 0 = top apex, 1 = bottom apex, 2..6 = U0..U4, 7..11 = L0..L4
      const verts = [];
      verts.push([0, +apexY, 0]);
      verts.push([0, -apexY, 0]);

      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * k) / n;
        verts.push([Math.cos(a) * r, +ringY, Math.sin(a) * r]);
      }
      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * (k + 0.5)) / n;
        verts.push([Math.cos(a) * r, -ringY, Math.sin(a) * r]);
      }

      const idx = [];
      const T = 0;
      const B = 1;
      const U0 = 2;
      const L0 = 7;

      // Each kite face is split into two triangles.
      // Top kites: [T, U_k, L_k, U_{k+1}]
      for (let k = 0; k < n; k++) {
        const Uk = U0 + k;
        const Uk1 = U0 + ((k + 1) % n);
        const Lk = L0 + k;
        idx.push(T, Uk, Lk);
        idx.push(T, Lk, Uk1);
      }
      // Bottom kites: [B, L_k, U_{k+1}, L_{k+1}]
      for (let k = 0; k < n; k++) {
        const Lk = L0 + k;
        const Lk1 = L0 + ((k + 1) % n);
        const Uk1 = U0 + ((k + 1) % n);
        idx.push(B, Lk, Uk1);
        idx.push(B, Uk1, Lk1);
      }

      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts.flat()), 3));
      g.setIndex(idx);
      ensureOutwardWinding(g);
      g.computeVertexNormals();
      g.computeBoundingBox();
      g.computeBoundingSphere();
      return g;
    }

    function createFaceLabelTexture(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.font = 'bold 120px system-ui, Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Outline for contrast.
      ctx.lineWidth = 10;
      ctx.strokeStyle = 'rgba(255,255,255,0.75)';
      ctx.strokeText(String(text), 128, 128);
      ctx.fillStyle = 'rgba(17,24,39,0.92)';
      ctx.fillText(String(text), 128, 128);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      tex.needsUpdate = true;
      return { canvas, ctx, tex };
    }

    function createFaceLabelPlane(text, scale = 0.45) {
      const plate = createFaceLabelTexture(text);
      const mat = new THREE.MeshBasicMaterial({
        map: plate.tex,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        side: THREE.DoubleSide,
        // Keep the label visually "printed" on the face without needing a large offset.
        polygonOffset: true,
        polygonOffsetFactor: -2,
        polygonOffsetUnits: -2,
      });
      const geo = new THREE.PlaneGeometry(scale, scale);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData._label = plate;
      return mesh;
    }

    function computeFaceGroups(geometry) {
      // Returns array of { normal, center, triangles:[{ia,ib,ic}] } for coplanar face groups.
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      if (!pos) return [];

      const epsDot = 0.9995;
      const epsD = 1e-3;
      const groups = [];

      const a = new THREE.Vector3();
      const b = new THREE.Vector3();
      const c = new THREE.Vector3();
      const n = new THREE.Vector3();
      const tmp = new THREE.Vector3();

      const triCount = index ? index.count : pos.count;
      for (let i = 0; i < triCount; i += 3) {
        const ia = index ? index.getX(i) : i;
        const ib = index ? index.getX(i + 1) : (i + 1);
        const ic = index ? index.getX(i + 2) : (i + 2);
        a.fromBufferAttribute(pos, ia);
        b.fromBufferAttribute(pos, ib);
        c.fromBufferAttribute(pos, ic);

        n.copy(b).sub(a).cross(tmp.copy(c).sub(a)).normalize();
        if (!Number.isFinite(n.x)) continue;
        let d = -n.dot(a);

        let found = null;
        for (const g of groups) {
          const dot = g.normal.dot(n);
          if (Math.abs(dot) <= epsDot) continue;

          if (dot > 0) {
            // Same normal direction -> same plane means d matches.
            if (Math.abs(g.d - d) < epsD) {
              found = g;
              break;
            }
          } else {
            // Opposite normal direction -> same plane means d is negated.
            if (Math.abs(g.d + d) < epsD) {
              // Align to group orientation for consistency.
              n.negate();
              d = -d;
              found = g;
              break;
            }
          }
        }

        if (!found) {
          found = { normal: n.clone(), d, triangles: [], center: new THREE.Vector3() };
          groups.push(found);
        }

        found.triangles.push({ ia, ib, ic });
      }

      // Compute centers and ensure normals point outward (convex, centered at origin)
      for (const g of groups) {
        const center = new THREE.Vector3();
        let count = 0;
        for (const t of g.triangles) {
          a.fromBufferAttribute(pos, t.ia);
          b.fromBufferAttribute(pos, t.ib);
          c.fromBufferAttribute(pos, t.ic);
          center.add(a).add(b).add(c);
          count += 3;
        }
        center.multiplyScalar(1 / Math.max(1, count));
        g.center.copy(center);
        if (g.normal.dot(center) < 0) {
          g.normal.negate();
          g.d = -g.d;
        }
      }

      return groups;
    }

    function addFaceNumberLabels(mesh, sides, faceGroups, valueByFace) {
      // Removes old face labels and adds new ones.
      if (mesh.userData.faceLabels) {
        for (const l of mesh.userData.faceLabels) mesh.remove(l);
      }
      mesh.userData.faceLabels = [];

      mesh.geometry.computeBoundingSphere();
      const rad = mesh.geometry.boundingSphere ? mesh.geometry.boundingSphere.radius : 1;
      // Keep labels very close to the surface. We rely on polygonOffset to avoid z-fighting.
      const offset = Math.max(0.004, rad * 0.012);

      const zAxis = new THREE.Vector3(0, 0, 1);
      const valueToNormal = new Map();
      const valueToFrame = new Map();

      const pos = mesh.geometry.getAttribute('position');
      const tmpA = new THREE.Vector3();
      const tmpB = new THREE.Vector3();
      const tmpC = new THREE.Vector3();
      const tmpU = new THREE.Vector3();

      for (let i = 0; i < faceGroups.length; i++) {
        const g = faceGroups[i];
        const v = valueByFace[i];
        if (!g || !Number.isFinite(v)) continue;

        // Determine a label size based on face area.
        let area = 0;
        for (const t of g.triangles) {
          tmpA.fromBufferAttribute(pos, t.ia);
          tmpB.fromBufferAttribute(pos, t.ib);
          tmpC.fromBufferAttribute(pos, t.ic);
          area += new THREE.Triangle(tmpA, tmpB, tmpC).getArea();
        }
        const labelSize = Math.max(0.20, Math.min(0.55, Math.sqrt(area) * 0.75));

        const displayText = (sides === 10 && v === 10) ? '0' : String(v);
        const label = createFaceLabelPlane(displayText, labelSize);
        label.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(zAxis, g.normal.clone().normalize()));
        label.position.copy(g.center).add(g.normal.clone().multiplyScalar(offset));
        label.renderOrder = 10;
        mesh.add(label);
        mesh.userData.faceLabels.push(label);

        // Keep internal mapping keyed by numeric value (10 stays 10 even if we display it as 0).
        if (!valueToNormal.has(v)) valueToNormal.set(v, g.normal.clone().normalize());

        // Also store a stable in-face tangent so we can align the face upright to the camera.
        // Pick a representative vertex direction from center and project it onto the face plane.
        let ia0 = null;
        if (g.triangles && g.triangles.length > 0) {
          ia0 = g.triangles[0].ia;
        }
        if (ia0 != null) {
          tmpA.fromBufferAttribute(pos, ia0);
          tmpU.copy(tmpA).sub(g.center);
          const nn = g.normal.clone().normalize();
          tmpU.sub(nn.clone().multiplyScalar(tmpU.dot(nn)));
          if (tmpU.lengthSq() > 1e-8) {
            tmpU.normalize();
            if (!valueToFrame.has(v)) valueToFrame.set(v, { normal: nn, u: tmpU.clone() });
          }
        }
      }

      mesh.userData.valueToNormal = valueToNormal;
      mesh.userData.valueToFrame = valueToFrame;
    }

    function buildOppositePairingValues(faceGroups, sides) {
      const faceCount = faceGroups.length;
      const used = new Array(faceCount).fill(false);
      const pairs = [];

      for (let i = 0; i < faceCount; i++) {
        if (used[i]) continue;
        let bestJ = -1;
        let bestDot = 1;
        for (let j = i + 1; j < faceCount; j++) {
          if (used[j]) continue;
          const dot = faceGroups[i].normal.dot(faceGroups[j].normal);
          if (dot < bestDot) {
            bestDot = dot;
            bestJ = j;
          }
        }
        if (bestJ >= 0) {
          used[i] = true;
          used[bestJ] = true;
          pairs.push([i, bestJ]);
        }
      }

      const valueByFace = new Array(faceCount).fill(null);
      const sum = sides + 1;
      let next = 1;
      for (const [a, b] of pairs) {
        valueByFace[a] = next;
        valueByFace[b] = sum - next;
        next++;
      }
      for (let i = 0; i < faceCount; i++) {
        if (valueByFace[i] == null) {
          valueByFace[i] = Math.min(sides, next);
          next++;
        }
      }
      return valueByFace;
    }

    function buildOppositePairs(faceGroups) {
      // For each face i, find its most-opposite face j (minimum dot).
      // Then keep only symmetric pairs where opp[opp[i]] === i.
      const n = faceGroups.length;
      if (n < 2) return [];

      const opp = new Array(n).fill(-1);
      for (let i = 0; i < n; i++) {
        let bestJ = -1;
        let bestDot = 2;
        const ni = faceGroups[i].normal;
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          const d = ni.dot(faceGroups[j].normal);
          if (d < bestDot) {
            bestDot = d;
            bestJ = j;
          }
        }
        opp[i] = bestJ;
      }

      const seen = new Array(n).fill(false);
      const pairs = [];
      for (let i = 0; i < n; i++) {
        if (seen[i]) continue;
        const j = opp[i];
        if (j < 0 || j >= n) continue;
        if (opp[j] !== i) continue;
        if (i === j) continue;
        seen[i] = true;
        seen[j] = true;
        pairs.push(i < j ? [i, j] : [j, i]);
      }

      // Deterministic ordering so results don't shuffle between runs.
      pairs.sort((p1, p2) => {
        const a = faceGroups[p1[0]].normal;
        const b = faceGroups[p2[0]].normal;
        // Prefer higher Y (top-ish) first, then Z, then X.
        if (a.y !== b.y) return b.y - a.y;
        if (a.z !== b.z) return b.z - a.z;
        return b.x - a.x;
      });

      return pairs;
    }

    function buildOppositeSumValues(faceGroups, sides, sum = sides + 1) {
      const pairs = buildOppositePairs(faceGroups);
      if (pairs.length * 2 !== faceGroups.length) return null;

      const valueByFace = new Array(faceGroups.length).fill(null);
      for (let k = 0; k < pairs.length; k++) {
        const low = k + 1;
        const high = sum - low;
        const [a, b] = pairs[k];
        valueByFace[a] = low;
        valueByFace[b] = high;
      }

      // Safety: ensure all assigned.
      if (valueByFace.some(v => v == null)) return null;
      return valueByFace;
    }

    function buildD10Values(faceGroups) {
      // D&D d10: faces typically labeled 1..9 and 0 (meaning 10).
      // Convention: opposite faces sum to 11 when treating 0 as 10.
      return buildOppositeSumValues(faceGroups, 10, 11);
    }

    function findFaceIndexByNormal(faceGroups, target, dotThreshold = 0.94) {
      let best = -1;
      let bestDot = -1;
      for (let i = 0; i < faceGroups.length; i++) {
        const d = faceGroups[i].normal.dot(target);
        if (d > bestDot) {
          bestDot = d;
          best = i;
        }
      }
      return bestDot >= dotThreshold ? best : -1;
    }

    function buildD6Values(faceGroups) {
      // Standard d6: opposites sum to 7 and right-handed (1 top, 2 front, 3 right).
      const v = new Array(faceGroups.length).fill(null);
      const px = new THREE.Vector3(1, 0, 0);
      const nx = new THREE.Vector3(-1, 0, 0);
      const py = new THREE.Vector3(0, 1, 0);
      const ny = new THREE.Vector3(0, -1, 0);
      const pz = new THREE.Vector3(0, 0, 1);
      const nz = new THREE.Vector3(0, 0, -1);

      const top = findFaceIndexByNormal(faceGroups, py);
      const bot = findFaceIndexByNormal(faceGroups, ny);
      const front = findFaceIndexByNormal(faceGroups, pz);
      const back = findFaceIndexByNormal(faceGroups, nz);
      const right = findFaceIndexByNormal(faceGroups, px);
      const left = findFaceIndexByNormal(faceGroups, nx);

      if ([top, bot, front, back, right, left].some(i => i < 0)) return null;

      v[top] = 1;
      v[bot] = 6;
      v[front] = 2;
      v[back] = 5;
      v[right] = 3;
      v[left] = 4;
      return v;
    }

    function buildD8Values(faceGroups) {
      // Deterministic d8 mapping by normal octant; opposites sum to 9.
      // This may not match every physical manufacturer, but it's consistent.
      const v = new Array(faceGroups.length).fill(null);
      const map = new Map();
      // Key by sign triple of normal components.
      map.set('+++', 1);
      map.set('---', 8);
      map.set('++-', 2);
      map.set('--+', 7);
      map.set('+-+', 3);
      map.set('-+-', 6);
      map.set('+--', 4);
      map.set('-++', 5);

      for (let i = 0; i < faceGroups.length; i++) {
        const n = faceGroups[i].normal;
        const sx = n.x >= 0 ? '+' : '-';
        const sy = n.y >= 0 ? '+' : '-';
        const sz = n.z >= 0 ? '+' : '-';
        const key = sx + sy + sz;
        const val = map.get(key);
        if (!val) return null;
        v[i] = val;
      }

      return v;
    }

    function makeDie(sides, geometry, x, faceGroups, valueByFace) {
      const mesh = new THREE.Mesh(geometry, baseMat.clone());
      mesh.castShadow = true;
      mesh.receiveShadow = false;
      mesh.userData = { sides };

      // Slightly different tint per die
      const tints = {
        4: 0xe5e7eb,
        6: 0xf8fafc,
        8: 0xe2e8f0,
        10: 0xf1f5f9,
        12: 0xe7e5e4,
        20: 0xf5f5f4,
      };
      mesh.material.color.setHex(tints[sides] || 0xf3f4f6);
      // Ensure cloned materials keep the same shading model and pick up env changes.
      mesh.material.flatShading = true;
      mesh.material.needsUpdate = true;

      // Place dice near the top of the tray.
      mesh.position.set(x, 2.2, 0);
      // Friendly isometric-ish pose.
      mesh.rotation.set(0.65, 0.55, 0.08);

      // Add per-face numbers.
      addFaceNumberLabels(mesh, sides, faceGroups, valueByFace);

      return mesh;
    }

    const dice = [];
    const ROLL_LANE_Y = 2.2;
    const ROLL_LANE_Z = 0.0;
    const ROLL_AXIS_Z = new THREE.Vector3(0, 0, 1);
    const _tmpV = new THREE.Vector3();
    const _tmpTravel = new THREE.Vector3();
    const _tmpRollAxis = new THREE.Vector3();
    const _tmpRay = new THREE.Ray();
    const _tmpPlane = new THREE.Plane();
    const _rollPlanePoint = new THREE.Vector3();
    const _rollPlaneNormal = new THREE.Vector3();
    const _rollPlaneRight = new THREE.Vector3();
    const _rollPlaneUp = new THREE.Vector3();
    const _tmpHit = new THREE.Vector3();
    const _tmpRel = new THREE.Vector3();
    const _tmpPos = new THREE.Vector3();
    const geometries = [
      [4, new THREE.TetrahedronGeometry(0.78, 0)],
      [6, new THREE.BoxGeometry(1.05, 1.05, 1.05)],
      [8, new THREE.OctahedronGeometry(0.82, 0)],
      [10, createD10Geometry(0.86)],
      [12, new THREE.DodecahedronGeometry(0.86, 0)],
      [20, new THREE.IcosahedronGeometry(0.9, 0)],
    ];

    const spacing = 1.65;
    const startX = -((geometries.length - 1) * spacing) / 2;

    for (let i = 0; i < geometries.length; i++) {
      const [sides, geo] = geometries[i];
      const x = startX + i * spacing;

      let faceGroups;
      let valueByFace;

      {
        faceGroups = computeFaceGroups(geo);
        if (sides === 4 && faceGroups.length === 4) {
          // User-requested: put 1,2,3,4 on the d4 faces.
          valueByFace = [1, 2, 3, 4];
        } else if (sides === 6 && faceGroups.length >= 6) {
          valueByFace = buildD6Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else if (sides === 8 && faceGroups.length === 8) {
          valueByFace = buildD8Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else if (sides === 10 && faceGroups.length === 10) {
          valueByFace = buildD10Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else if ((sides === 12 || sides === 20) && faceGroups.length === sides) {
          // D12: opposites sum to 13. D20: opposites sum to 21.
          valueByFace = buildOppositeSumValues(faceGroups, sides) || buildOppositePairingValues(faceGroups, sides);
        } else {
          valueByFace = buildOppositePairingValues(faceGroups, sides);
        }
      }

      const mesh = makeDie(sides, geo, x, faceGroups, valueByFace);
      const lines = makeEdges(mesh);
      scene.add(mesh);
      scene.add(lines);

      // Cache a stable collision radius for this die.
      try {
        geo.computeBoundingSphere();
        mesh.userData.radius = geo.boundingSphere ? geo.boundingSphere.radius : 0.85;
      } catch {
        mesh.userData.radius = 0.85;
      }

      mesh.userData.slotX = x;
      mesh.userData.slotY = ROLL_LANE_Y;
      mesh.userData.slotZ = ROLL_LANE_Z;
      dice.push({ mesh, lines, sides, anim: null });
    }

    function fract(x) { return x - Math.floor(x); }
    function prng(seed) { return fract(Math.sin(seed) * 43758.5453123); }

    function worldXAtPlaneY(ndcX, ndcY, yPlane) {
      // Ray from camera through NDC point, intersect with plane Y = yPlane.
      _tmpV.set(ndcX, ndcY, 0.5).unproject(camera);
      _tmpRay.origin.copy(camera.position);
      _tmpRay.direction.copy(_tmpV).sub(camera.position).normalize();
      _tmpPlane.set(new THREE.Vector3(0, 1, 0), -yPlane);
      const hit = new THREE.Vector3();
      const ok = _tmpRay.intersectPlane(_tmpPlane, hit);
      return ok ? hit.x : 0;
    }

    function worldPointAtPlaneY(ndcX, ndcY, yPlane, out) {
      // Ray from camera through NDC point, intersect with plane Y = yPlane.
      _tmpV.set(ndcX, ndcY, 0.5).unproject(camera);
      _tmpRay.origin.copy(camera.position);
      _tmpRay.direction.copy(_tmpV).sub(camera.position).normalize();
      _tmpPlane.set(new THREE.Vector3(0, 1, 0), -yPlane);
      return _tmpRay.intersectPlane(_tmpPlane, out);
    }

    function updateRollPlaneBasis() {
      // The "screen" plane: perpendicular to camera forward, passing through the dice lane center.
      _rollPlanePoint.set(0, ROLL_LANE_Y, ROLL_LANE_Z);
      camera.getWorldDirection(_rollPlaneNormal).normalize();
      _rollPlaneRight.set(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
      _rollPlaneUp.set(0, 1, 0).applyQuaternion(camera.quaternion).normalize();
    }

    function worldPointAtRollPlane(ndcX, ndcY, out) {
      // Ray from camera through NDC point, intersect with the roll plane.
      _tmpV.set(ndcX, ndcY, 0.5).unproject(camera);
      _tmpRay.origin.copy(camera.position);
      _tmpRay.direction.copy(_tmpV).sub(camera.position).normalize();
      _tmpPlane.set(_rollPlaneNormal, -_rollPlaneNormal.dot(_rollPlanePoint));
      return _tmpRay.intersectPlane(_tmpPlane, out);
    }

    function rollPlaneUVAtNdc(ndcX, ndcY, outUV) {
      const hit = worldPointAtRollPlane(ndcX, ndcY, _tmpHit);
      if (!hit) return null;
      _tmpRel.copy(_tmpHit).sub(_rollPlanePoint);
      outUV.u = _tmpRel.dot(_rollPlaneRight);
      outUV.v = _tmpRel.dot(_rollPlaneUp);
      return outUV;
    }

    function resize() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      updateRollPlaneBasis();
    }

    window.addEventListener('resize', resize);
    resize();

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function postDie(sides) {
      const payload = JSON.stringify({ type: 'die', sides });
      if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
        window.chrome.webview.postMessage(payload);
      }
    }

    function postRotate(sides, q) {
      // q is a THREE.Quaternion
      const payload = JSON.stringify({ type: 'rotate', sides, q: [q.x, q.y, q.z, q.w] });
      if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
        window.chrome.webview.postMessage(payload);
      }
    }

    function pickDieAt(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((clientY - rect.top) / rect.height) * 2 - 1);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(dice.map(d => d.mesh), false);
      if (hits.length <= 0) return null;
      const hitMesh = hits[0].object;
      return dice.find(d => d.mesh === hitMesh) || null;
    }

    // Click = roll, drag = rotate die for inspection.
    let activeDrag = null; // { die, pointerId, startX, startY, lastX, lastY, dragging, lastSentMs }
    const DRAG_THRESHOLD_PX = 4;
    const ROT_SPEED = 0.007;
    const ROT_SEND_INTERVAL_MS = 33;

    canvas.addEventListener('pointerdown', (ev) => {
      // Only primary button / primary touch.
      if (ev.isPrimary === false) return;
      if (ev.button != null && ev.button !== 0) return;

      const die = pickDieAt(ev.clientX, ev.clientY);
      if (!die) return;

      activeDrag = {
        die,
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        lastX: ev.clientX,
        lastY: ev.clientY,
        dragging: false,
        lastSentMs: 0,
      };

      try { canvas.setPointerCapture(ev.pointerId); } catch { }
      ev.preventDefault();
    });

    canvas.addEventListener('pointermove', (ev) => {
      if (!activeDrag) return;
      if (ev.pointerId !== activeDrag.pointerId) return;

      const dxTotal = ev.clientX - activeDrag.startX;
      const dyTotal = ev.clientY - activeDrag.startY;
      const dist = Math.hypot(dxTotal, dyTotal);
      if (!activeDrag.dragging && dist >= DRAG_THRESHOLD_PX) {
        activeDrag.dragging = true;
        // Cancel any roll animation while inspecting.
        activeDrag.die.anim = null;
      }

      if (activeDrag.dragging) {
        const dx = ev.clientX - activeDrag.lastX;
        const dy = ev.clientY - activeDrag.lastY;

        // Horizontal drag: spin around world up.
        activeDrag.die.mesh.rotateOnWorldAxis(UP, dx * ROT_SPEED);

        // Vertical drag: tilt around camera-right axis so it feels natural.
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion).normalize();
        activeDrag.die.mesh.rotateOnWorldAxis(right, dy * ROT_SPEED);

        const now = performance.now();
        if ((now - activeDrag.lastSentMs) >= ROT_SEND_INTERVAL_MS) {
          activeDrag.lastSentMs = now;
          postRotate(activeDrag.die.sides, activeDrag.die.mesh.quaternion);
        }
      }

      activeDrag.lastX = ev.clientX;
      activeDrag.lastY = ev.clientY;
      ev.preventDefault();
    });

    function endDrag(ev) {
      if (!activeDrag) return;
      if (ev.pointerId !== activeDrag.pointerId) return;

      const die = activeDrag.die;
      const shouldClick = !activeDrag.dragging;

      try { canvas.releasePointerCapture(ev.pointerId); } catch { }
      activeDrag = null;

      if (shouldClick && die) {
        postDie(die.sides);
      } else if (die) {
        // Send final rotation on drag end.
        postRotate(die.sides, die.mesh.quaternion);
      }

      ev.preventDefault();
    }

    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', endDrag);

    function applyIdlePose(d) {
      d.mesh.rotation.set(0.65, 0.55, 0.08);
      d.anim = null;
    }

    const UP = new THREE.Vector3(0, 1, 0);
    const _tmpCamDir = new THREE.Vector3();
    const _tmpUp = new THREE.Vector3();
    const _tmpV1 = new THREE.Vector3();
    const _tmpV2 = new THREE.Vector3();
    const _tmpV3 = new THREE.Vector3();
    const _tmpQ = new THREE.Quaternion();

    function quaternionForValue(mesh, value) {
      const frames = mesh.userData.valueToFrame;
      const normals = mesh.userData.valueToNormal;

      const frame = frames && frames.get ? frames.get(value) : null;
      const n = frame?.normal || (normals && normals.get ? normals.get(value) : null);
      if (!n) return null;

      // Target normal: aim at the camera along the view ray for THIS die.
      // In a perspective camera, using camera forward can look "not quite flat" for off-center objects.
      _tmpCamDir.copy(camera.position).sub(mesh.position);
      if (_tmpCamDir.lengthSq() < 1e-8) {
        _tmpCamDir.copy(UP);
      }
      _tmpCamDir.normalize();

      // First rotate the face normal to the target normal.
      const q1 = _tmpQ.setFromUnitVectors(n.clone().normalize(), _tmpCamDir);

      // If we have a stable in-face tangent, add a deterministic twist so the face is upright.
      if (frame && frame.u) {
        // Camera up in world space.
        _tmpUp.set(0, 1, 0).applyQuaternion(camera.quaternion).normalize();

        // Project desired up onto the face plane.
        const targetUp = _tmpV1.copy(_tmpUp).sub(_tmpCamDir.clone().multiplyScalar(_tmpUp.dot(_tmpCamDir)));
        if (targetUp.lengthSq() > 1e-8) {
          targetUp.normalize();

          // Current face-U in world space after q1.
          const uWorld = _tmpV2.copy(frame.u).applyQuaternion(q1);
          const uProj = _tmpV3.copy(uWorld).sub(_tmpCamDir.clone().multiplyScalar(uWorld.dot(_tmpCamDir)));
          if (uProj.lengthSq() > 1e-8) {
            uProj.normalize();

            // Signed angle from uProj -> targetUp around _tmpCamDir.
            const cross = uProj.clone().cross(targetUp);
            const sin = cross.dot(_tmpCamDir);
            const cos = Math.max(-1, Math.min(1, uProj.dot(targetUp)));
            const angle = Math.atan2(sin, cos);

            const qTwist = new THREE.Quaternion().setFromAxisAngle(_tmpCamDir, angle);
            // Apply twist in world space: q = qTwist * q1
            return q1.premultiply(qTwist);
          }
        }
      }

      return q1;
    }

    function kickRollToValue(d, value) {
      const targetQ = quaternionForValue(d.mesh, value);
      const seed = (d.sides * 1000) + (value * 17);
      const r1 = prng(seed + 1);
      const r2 = prng(seed + 2);
      const r3 = prng(seed + 3);
      const r4 = prng(seed + 4);
      const r5 = prng(seed + 5);
      const r6 = prng(seed + 6);

      const startQ = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(r1 * Math.PI * 2, r2 * Math.PI * 2, r3 * Math.PI * 2)
      );
      d.mesh.quaternion.copy(startQ);

      // Roll lane bounds in the camera-facing plane so dice keep a fixed distance from the screen.
      // (No perspective size changes from moving toward/away from the camera.)
      const uv = { u: 0, v: 0 };
      rollPlaneUVAtNdc(-1, 0, uv);
      const uLeft = uv.u + 0.6;
      rollPlaneUVAtNdc(1, 0, uv);
      const uRight = uv.u - 0.6;
      rollPlaneUVAtNdc(0, -1, uv);
      const vMin0 = uv.v + 0.6;
      rollPlaneUVAtNdc(0, 1, uv);
      const vMax0 = uv.v - 0.6;
      const vMin = Math.min(vMin0, vMax0);
      const vMax = Math.max(vMin0, vMax0);

      // Start left and roll across the "table". Use friction-like deceleration and bounce
      // off side walls (left/right) if we hit them.
      const startU = uLeft;
      const laneW = Math.max(0.001, uRight - uLeft);
      const a = 9.0; // units/s^2 (speed bleed)

      // Pick a speed that will usually reach the right wall and bounce at least once.
      // If unbounded, stopping distance would be v0^2/(2a). Use ~1.6x lane width.
      const v0 = Math.sqrt(2 * a * laneW * 1.6);
      const restitution = 0.55 + 0.15 * r4; // energy kept on bounce

      const rad = (d.mesh.userData && Number.isFinite(d.mesh.userData.radius)) ? d.mesh.userData.radius : 0.85;

      // Deterministic tumble axis (so portal/control look the same).
      const tumbleAxis = new THREE.Vector3(r4 - 0.5, r5 - 0.5, r6 - 0.5);
      if (tumbleAxis.lengthSq() < 1e-6) tumbleAxis.set(1, 0.3, 0.2);
      tumbleAxis.normalize();

      // Randomize incoming direction within +/-30 degrees (still left->right overall).
      const maxAngle = 30 * (Math.PI / 180);
      const theta = (r2 * 2 - 1) * maxAngle;
      const vu0 = v0 * Math.cos(theta);
      const vv0 = v0 * Math.sin(theta);

      // Place the die on the roll plane at (uLeft, v=0).
      _tmpPos.copy(_rollPlanePoint)
        .addScaledVector(_rollPlaneRight, startU)
        .addScaledVector(_rollPlaneUp, 0);
      d.mesh.position.copy(_tmpPos);
      d.anim = {
        type: 'physicsRoll',
        t: 0,
        a,
        vu: vu0,
        vv: vv0,
        u: startU,
        v: 0,
        uLeft,
        uRight,
        vMin,
        vMax,
        planePoint: _rollPlanePoint.clone(),
        planeNormal: _rollPlaneNormal.clone(),
        planeRight: _rollPlaneRight.clone(),
        planeUp: _rollPlaneUp.clone(),
        restitution,
        rad,
        tumbleAxis,
        startQ,
        targetQ: targetQ || new THREE.Quaternion().setFromEuler(new THREE.Euler(0.65, 0.55, 0.08)),
        settleT: 0,
        settleDur: 0.30,
        settleFromQ: d.mesh.quaternion.clone(),
        restTime: 0,
      };
    }

    function setPreview() {
      for (const d of dice) {
        applyIdlePose(d);
      }
    }

    function showRollResults(items) {
      // items: [{sides,value}]
      const buckets = new Map();
      for (const it of items || []) {
        const s = Number(it.sides);
        let v = Number(it.value);
        if (!Number.isFinite(s) || !Number.isFinite(v)) continue;

        // d10 may come through as 0 (meaning 10) depending on upstream formatting.
        if (s === 10 && v === 0) v = 10;

        if (!buckets.has(s)) buckets.set(s, []);
        buckets.get(s).push(v);
      }

      for (const d of dice) {
        const values = buckets.get(d.sides) || [];
        if (values.length > 0) {
          const v = values.shift();
          kickRollToValue(d, v);
        }
      }
    }

    // Messages from host (C#): {type:'preview'} or {type:'roll', dice:[{sides,value}]}
    if (window.chrome && window.chrome.webview) {
      window.chrome.webview.addEventListener('message', (ev) => {
        try {
          const msg = typeof ev.data === 'string' ? JSON.parse(ev.data) : ev.data;
          if (!msg || !msg.type) return;
          if (msg.type === 'preview') setPreview();
          if (msg.type === 'roll') showRollResults(msg.dice || []);
          if (msg.type === 'setRotation') {
            const sides = Number(msg.sides);
            const q = msg.q;
            if (!Number.isFinite(sides) || !Array.isArray(q) || q.length !== 4) return;
            const d = dice.find(dd => dd.sides === sides);
            if (!d) return;
            const x = Number(q[0]);
            const y = Number(q[1]);
            const z = Number(q[2]);
            const w = Number(q[3]);
            if (![x, y, z, w].every(Number.isFinite)) return;
            d.anim = null;
            d.mesh.quaternion.set(x, y, z, w).normalize();
          }
        } catch { }
      });
    }

    setPreview();

    let t0 = performance.now();
    function animate() {
      const t = performance.now();
      const dt = (t - t0) / 1000;
      t0 = t;

      for (const d of dice) {
        if (d.anim) {
          if (d.anim.type === 'physicsRoll') {
            d.anim.t += dt;
            // Integrate velocity on the roll plane with simple kinetic friction (bleed speed magnitude).
            const speed0 = Math.hypot(d.anim.vu, d.anim.vv);
            const speed1 = Math.max(0, speed0 - d.anim.a * dt);
            if (speed0 > 1e-6) {
              const s = speed1 / speed0;
              d.anim.vu *= s;
              d.anim.vv *= s;
            } else {
              d.anim.vu = 0;
              d.anim.vv = 0;
            }

            d.anim.u += d.anim.vu * dt;
            d.anim.v += d.anim.vv * dt;

            // Bounce off bounds in plane coordinates.
            let bounced = false;
            if (d.anim.u >= d.anim.uRight) {
              d.anim.u = d.anim.uRight;
              d.anim.vu = -Math.abs(d.anim.vu) * d.anim.restitution;
              bounced = true;
            } else if (d.anim.u <= d.anim.uLeft) {
              d.anim.u = d.anim.uLeft;
              d.anim.vu = Math.abs(d.anim.vu) * d.anim.restitution;
              bounced = true;
            }
            if (d.anim.v >= d.anim.vMax) {
              d.anim.v = d.anim.vMax;
              d.anim.vv = -Math.abs(d.anim.vv) * d.anim.restitution;
              bounced = true;
            } else if (d.anim.v <= d.anim.vMin) {
              d.anim.v = d.anim.vMin;
              d.anim.vv = Math.abs(d.anim.vv) * d.anim.restitution;
              bounced = true;
            }

            // Die-to-die collisions: bounce off other dice on the lane.
            for (const other of dice) {
              if (other === d) continue;
              const r1 = d.anim.rad;
              const r2 = (other.mesh.userData && Number.isFinite(other.mesh.userData.radius)) ? other.mesh.userData.radius : 0.85;

              // Other die's plane coordinates (even if idle, it's on the same roll plane).
              _tmpRel.copy(other.mesh.position).sub(d.anim.planePoint);
              const ou = _tmpRel.dot(d.anim.planeRight);
              const ov = _tmpRel.dot(d.anim.planeUp);

              const du = d.anim.u - ou;
              const dv = d.anim.v - ov;
              const dist = Math.hypot(du, dv);
              const minDist = Math.max(0.001, r1 + r2);
              if (dist >= minDist) continue;

              // Separate (treat the other die as static unless it's also rolling).
              const nx = dist > 1e-6 ? (du / dist) : 1;
              const nz = dist > 1e-6 ? (dv / dist) : 0;
              const pen = (minDist - dist) + 1e-3;

              const otherRolling = other.anim && other.anim.type === 'physicsRoll';
              if (!otherRolling) {
                d.anim.u += nx * pen;
                d.anim.v += nz * pen;

                // Nudge the idle die a bit in-plane so it "gets hit".
                const push = pen * 0.25;
                const newOu = ou - nx * push;
                const newOv = ov - nz * push;
                other.mesh.position.copy(d.anim.planePoint)
                  .addScaledVector(d.anim.planeRight, newOu)
                  .addScaledVector(d.anim.planeUp, newOv);
              } else {
                d.anim.u += nx * (pen * 0.5);
                d.anim.v += nz * (pen * 0.5);
                other.anim.u -= nx * (pen * 0.5);
                other.anim.v -= nz * (pen * 0.5);

                // Apply immediately to keep both dice on the same plane.
                other.mesh.position.copy(other.anim.planePoint)
                  .addScaledVector(other.anim.planeRight, other.anim.u)
                  .addScaledVector(other.anim.planeUp, other.anim.v);
              }

              // Compute bounce response along collision normal.
              const e = Math.min(d.anim.restitution, otherRolling ? other.anim.restitution : d.anim.restitution);
              if (!otherRolling) {
                const vdot = d.anim.vu * nx + d.anim.vv * nz;
                if (vdot < 0) {
                  d.anim.vu -= (1 + e) * vdot * nx;
                  d.anim.vv -= (1 + e) * vdot * nz;
                  bounced = true;
                }

                // Visual impact on the stationary die.
                // Keep it strictly on the table plane: a small yaw spin reads as a bump without any "hop".
                other.mesh.rotateOnWorldAxis(UP, (Math.random() - 0.5) * 0.18);
              } else {
                const rvx = d.anim.vu - other.anim.vu;
                const rvz = d.anim.vv - other.anim.vv;
                const rel = rvx * nx + rvz * nz;
                if (rel < 0) {
                  const j = -(1 + e) * rel / 2; // equal mass
                  d.anim.vu += j * nx;
                  d.anim.vv += j * nz;
                  other.anim.vu -= j * nx;
                  other.anim.vv -= j * nz;
                  bounced = true;
                }
              }
            }

            // Convert plane coordinates back to world position (constant distance from screen).
            d.mesh.position.copy(d.anim.planePoint)
              .addScaledVector(d.anim.planeRight, d.anim.u)
              .addScaledVector(d.anim.planeUp, d.anim.v);

            // Rolling: primary rotation proportional to speed, axis derived from travel direction.
            const speed = Math.hypot(d.anim.vu, d.anim.vv);
            const omega = (speed / Math.max(0.001, d.anim.rad));
            const dTheta = omega * dt;
            if (speed > 1e-6) {
              _tmpTravel.copy(d.anim.planeRight).multiplyScalar(d.anim.vu)
                .addScaledVector(d.anim.planeUp, d.anim.vv)
                .normalize();
              _tmpRollAxis.copy(d.anim.planeNormal).cross(_tmpTravel);
              if (_tmpRollAxis.lengthSq() > 1e-6) {
                _tmpRollAxis.normalize();
                d.mesh.rotateOnWorldAxis(_tmpRollAxis, dTheta);
              }
            }
            d.mesh.rotateOnWorldAxis(d.anim.tumbleAxis, dTheta * 0.65);

            // Add a small extra tumble impulse on bounce so it feels less "linear".
            if (bounced) {
              const bump = 0.18;
              d.mesh.rotateOnWorldAxis(d.anim.tumbleAxis, (Math.random() - 0.5) * bump);
            }

            // Once we've basically stopped for a short moment, settle to the exact face-on pose.
            if (Math.hypot(d.anim.vu, d.anim.vv) < 0.10) {
              d.anim.restTime += dt;
            } else {
              d.anim.restTime = 0;
            }

            if (d.anim.restTime >= 0.10) {
              // Settle to exact face-on orientation.
              d.anim.type = 'settle';
              d.anim.settleT = 0;
              d.anim.settleFromQ = d.mesh.quaternion.clone();
            }
          } else if (d.anim.type === 'settle') {
            d.anim.settleT += dt;
            const u = Math.min(1, d.anim.settleT / d.anim.settleDur);
            const s = u * u * (3 - 2 * u);
            d.mesh.quaternion.slerpQuaternions(d.anim.settleFromQ, d.anim.targetQ, s);
            if (u >= 1) {
              d.anim = null;
            }
          } else {
            // Back-compat: older animation objects.
            d.anim.t += dt;
            const u = Math.min(1, d.anim.t / d.anim.duration);
            const s = u * u * (3 - 2 * u);
            d.mesh.quaternion.slerpQuaternions(d.anim.start, d.anim.target, s);
            if (u >= 1) d.anim = null;
          }
        }

        d.lines.position.copy(d.mesh.position);
        d.lines.quaternion.copy(d.mesh.quaternion);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
