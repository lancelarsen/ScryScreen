<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScryScreen Dice Tray</title>
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#0A0F18; }
    #c { display:block; width:100%; height:100%; }
    .hint { position:absolute; left:10px; top:8px; color:#94a3b8; font: 12px/1.2 system-ui, Segoe UI, sans-serif; opacity:0.85; user-select:none; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Click a die: d4 d6 d8 d10 d12 d20</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setClearColor(0x0A0F18, 1);

    const scene = new THREE.Scene();

    // Camera is framed so dice live near the *top* of the view.
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 60);
    camera.position.set(0, 6.0, 11.0);
    camera.lookAt(0, 2.5, 0);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x111827, 0.9);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.3);
    dir.position.set(5, 7, 6);
    scene.add(dir);

    const floorGeo = new THREE.PlaneGeometry(30, 14);
    const floorMat = new THREE.ShadowMaterial({ opacity: 0.25 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0.0;
    floor.receiveShadow = true;
    scene.add(floor);

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const metal = 0.1;
    const rough = 0.28;
    const baseMat = new THREE.MeshStandardMaterial({
      color: 0xf3f4f6,
      metalness: metal,
      roughness: rough,
      envMapIntensity: 0.35,
    });

    function makeEdges(mesh) {
      const eg = new THREE.EdgesGeometry(mesh.geometry, 25);
      const lm = new THREE.LineBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.8 });
      const lines = new THREE.LineSegments(eg, lm);
      lines.position.copy(mesh.position);
      lines.quaternion.copy(mesh.quaternion);
      lines.scale.copy(mesh.scale);
      return lines;
    }

    // D10: pentagonal trapezohedron built as indexed triangles.
    // Important: the two triangles that make each kite must be coplanar, otherwise
    // EdgesGeometry will show the diagonal and the shape looks "broken".
    function createD10Geometry(radius = 0.86) {
      const n = 5;

      // Planarity constraint for this construction: apexDistance / ringPlaneOffset â‰ˆ 9.472135955
      const apexToPlane = 9.47213595499958;

      const apexY = radius * 0.90;
      const ringY = apexY / apexToPlane;
      const r = radius * 0.82;

      // Vertex layout (Y-up):
      // 0 = top apex, 1 = bottom apex, 2..6 = U0..U4, 7..11 = L0..L4
      const verts = [];
      verts.push([0, +apexY, 0]);
      verts.push([0, -apexY, 0]);

      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * k) / n;
        verts.push([Math.cos(a) * r, +ringY, Math.sin(a) * r]);
      }
      for (let k = 0; k < n; k++) {
        const a = (Math.PI * 2 * (k + 0.5)) / n;
        verts.push([Math.cos(a) * r, -ringY, Math.sin(a) * r]);
      }

      const idx = [];
      const T = 0;
      const B = 1;
      const U0 = 2;
      const L0 = 7;

      // Each kite face is split into two triangles.
      // Top kites: [T, U_k, L_k, U_{k+1}]
      for (let k = 0; k < n; k++) {
        const Uk = U0 + k;
        const Uk1 = U0 + ((k + 1) % n);
        const Lk = L0 + k;
        idx.push(T, Uk, Lk);
        idx.push(T, Lk, Uk1);
      }
      // Bottom kites: [B, L_k, U_{k+1}, L_{k+1}]
      for (let k = 0; k < n; k++) {
        const Lk = L0 + k;
        const Lk1 = L0 + ((k + 1) % n);
        const Uk1 = U0 + ((k + 1) % n);
        idx.push(B, Lk, Uk1);
        idx.push(B, Uk1, Lk1);
      }

      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts.flat()), 3));
      g.setIndex(idx);
      g.computeVertexNormals();
      g.computeBoundingBox();
      g.computeBoundingSphere();
      return g;
    }

    function createBadgeTexture(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // background plate
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.beginPath();
      ctx.roundRect(24, 24, 208, 208, 26);
      ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.font = 'bold 92px system-ui, Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(text), 128, 128);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      tex.needsUpdate = true;
      return { canvas, ctx, tex };
    }

    function createBadgePlane(text, scale = 0.55) {
      const plate = createBadgeTexture(text);
      const mat = new THREE.MeshBasicMaterial({ map: plate.tex, transparent: true, depthTest: true });
      const geo = new THREE.PlaneGeometry(scale, scale);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData._label = plate;
      return mesh;
    }

    function createFaceLabelTexture(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.font = 'bold 120px system-ui, Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Outline for contrast.
      ctx.lineWidth = 10;
      ctx.strokeStyle = 'rgba(255,255,255,0.75)';
      ctx.strokeText(String(text), 128, 128);
      ctx.fillStyle = 'rgba(17,24,39,0.92)';
      ctx.fillText(String(text), 128, 128);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      tex.needsUpdate = true;
      return { canvas, ctx, tex };
    }

    function createFaceLabelPlane(text, scale = 0.45) {
      const plate = createFaceLabelTexture(text);
      const mat = new THREE.MeshBasicMaterial({ map: plate.tex, transparent: true, depthTest: true, depthWrite: false, side: THREE.DoubleSide });
      const geo = new THREE.PlaneGeometry(scale, scale);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData._label = plate;
      return mesh;
    }

    function setLabel(labelMesh, text) {
      const plate = labelMesh.userData._label;
      if (!plate) return;
      const ctx = plate.ctx;
      ctx.clearRect(0, 0, 256, 256);
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.beginPath();
      ctx.roundRect(24, 24, 208, 208, 26);
      ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.font = 'bold 92px system-ui, Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(text), 128, 128);

      plate.tex.needsUpdate = true;
    }

    function computeFaceGroups(geometry) {
      // Returns array of { normal, center, triangles:[{ia,ib,ic}] } for coplanar face groups.
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      if (!pos) return [];

      const epsDot = 0.9995;
      const epsD = 1e-3;
      const groups = [];

      const a = new THREE.Vector3();
      const b = new THREE.Vector3();
      const c = new THREE.Vector3();
      const n = new THREE.Vector3();
      const tmp = new THREE.Vector3();

      const triCount = index ? index.count : pos.count;
      for (let i = 0; i < triCount; i += 3) {
        const ia = index ? index.getX(i) : i;
        const ib = index ? index.getX(i + 1) : (i + 1);
        const ic = index ? index.getX(i + 2) : (i + 2);
        a.fromBufferAttribute(pos, ia);
        b.fromBufferAttribute(pos, ib);
        c.fromBufferAttribute(pos, ic);

        n.copy(b).sub(a).cross(tmp.copy(c).sub(a)).normalize();
        if (!Number.isFinite(n.x)) continue;
        let d = -n.dot(a);

        let found = null;
        for (const g of groups) {
          const dot = g.normal.dot(n);
          if (Math.abs(dot) <= epsDot) continue;

          if (dot > 0) {
            // Same normal direction -> same plane means d matches.
            if (Math.abs(g.d - d) < epsD) {
              found = g;
              break;
            }
          } else {
            // Opposite normal direction -> same plane means d is negated.
            if (Math.abs(g.d + d) < epsD) {
              // Align to group orientation for consistency.
              n.negate();
              d = -d;
              found = g;
              break;
            }
          }
        }

        if (!found) {
          found = { normal: n.clone(), d, triangles: [], center: new THREE.Vector3() };
          groups.push(found);
        }

        found.triangles.push({ ia, ib, ic });
      }

      // Compute centers and ensure normals point outward (convex, centered at origin)
      for (const g of groups) {
        const center = new THREE.Vector3();
        let count = 0;
        for (const t of g.triangles) {
          a.fromBufferAttribute(pos, t.ia);
          b.fromBufferAttribute(pos, t.ib);
          c.fromBufferAttribute(pos, t.ic);
          center.add(a).add(b).add(c);
          count += 3;
        }
        center.multiplyScalar(1 / Math.max(1, count));
        g.center.copy(center);
        if (g.normal.dot(center) < 0) {
          g.normal.negate();
          g.d = -g.d;
        }
      }

      return groups;
    }

    function addFaceNumberLabels(mesh, sides, faceGroups, valueByFace) {
      // Removes old face labels and adds new ones.
      if (mesh.userData.faceLabels) {
        for (const l of mesh.userData.faceLabels) mesh.remove(l);
      }
      mesh.userData.faceLabels = [];

      mesh.geometry.computeBoundingSphere();
      const rad = mesh.geometry.boundingSphere ? mesh.geometry.boundingSphere.radius : 1;
      const offset = Math.max(0.02, rad * 0.07);

      const zAxis = new THREE.Vector3(0, 0, 1);
      const valueToNormal = new Map();

      const pos = mesh.geometry.getAttribute('position');
      const tmpA = new THREE.Vector3();
      const tmpB = new THREE.Vector3();
      const tmpC = new THREE.Vector3();

      for (let i = 0; i < faceGroups.length; i++) {
        const g = faceGroups[i];
        const v = valueByFace[i];
        if (!g || !Number.isFinite(v)) continue;

        // Determine a label size based on face area.
        let area = 0;
        for (const t of g.triangles) {
          tmpA.fromBufferAttribute(pos, t.ia);
          tmpB.fromBufferAttribute(pos, t.ib);
          tmpC.fromBufferAttribute(pos, t.ic);
          area += new THREE.Triangle(tmpA, tmpB, tmpC).getArea();
        }
        const labelSize = Math.max(0.20, Math.min(0.55, Math.sqrt(area) * 0.75));

        const displayText = (sides === 10 && v === 10) ? '0' : String(v);
        const label = createFaceLabelPlane(displayText, labelSize);
        label.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(zAxis, g.normal.clone().normalize()));
        label.position.copy(g.center).add(g.normal.clone().multiplyScalar(offset));
        label.renderOrder = 10;
        mesh.add(label);
        mesh.userData.faceLabels.push(label);

        // Keep internal mapping keyed by numeric value (10 stays 10 even if we display it as 0).
        if (!valueToNormal.has(v)) valueToNormal.set(v, g.normal.clone().normalize());
      }

      mesh.userData.valueToNormal = valueToNormal;
    }

    function buildOppositePairingValues(faceGroups, sides) {
      const faceCount = faceGroups.length;
      const used = new Array(faceCount).fill(false);
      const pairs = [];

      for (let i = 0; i < faceCount; i++) {
        if (used[i]) continue;
        let bestJ = -1;
        let bestDot = 1;
        for (let j = i + 1; j < faceCount; j++) {
          if (used[j]) continue;
          const dot = faceGroups[i].normal.dot(faceGroups[j].normal);
          if (dot < bestDot) {
            bestDot = dot;
            bestJ = j;
          }
        }
        if (bestJ >= 0) {
          used[i] = true;
          used[bestJ] = true;
          pairs.push([i, bestJ]);
        }
      }

      const valueByFace = new Array(faceCount).fill(null);
      const sum = sides + 1;
      let next = 1;
      for (const [a, b] of pairs) {
        valueByFace[a] = next;
        valueByFace[b] = sum - next;
        next++;
      }
      for (let i = 0; i < faceCount; i++) {
        if (valueByFace[i] == null) {
          valueByFace[i] = Math.min(sides, next);
          next++;
        }
      }
      return valueByFace;
    }

    function findFaceIndexByNormal(faceGroups, target, dotThreshold = 0.94) {
      let best = -1;
      let bestDot = -1;
      for (let i = 0; i < faceGroups.length; i++) {
        const d = faceGroups[i].normal.dot(target);
        if (d > bestDot) {
          bestDot = d;
          best = i;
        }
      }
      return bestDot >= dotThreshold ? best : -1;
    }

    function buildD6Values(faceGroups) {
      // Standard d6: opposites sum to 7 and right-handed (1 top, 2 front, 3 right).
      const v = new Array(faceGroups.length).fill(null);
      const px = new THREE.Vector3(1, 0, 0);
      const nx = new THREE.Vector3(-1, 0, 0);
      const py = new THREE.Vector3(0, 1, 0);
      const ny = new THREE.Vector3(0, -1, 0);
      const pz = new THREE.Vector3(0, 0, 1);
      const nz = new THREE.Vector3(0, 0, -1);

      const top = findFaceIndexByNormal(faceGroups, py);
      const bot = findFaceIndexByNormal(faceGroups, ny);
      const front = findFaceIndexByNormal(faceGroups, pz);
      const back = findFaceIndexByNormal(faceGroups, nz);
      const right = findFaceIndexByNormal(faceGroups, px);
      const left = findFaceIndexByNormal(faceGroups, nx);

      if ([top, bot, front, back, right, left].some(i => i < 0)) return null;

      v[top] = 1;
      v[bot] = 6;
      v[front] = 2;
      v[back] = 5;
      v[right] = 3;
      v[left] = 4;
      return v;
    }

    function buildD8Values(faceGroups) {
      // Deterministic d8 mapping by normal octant; opposites sum to 9.
      // This may not match every physical manufacturer, but it's consistent.
      const v = new Array(faceGroups.length).fill(null);
      const map = new Map();
      // Key by sign triple of normal components.
      map.set('+++', 1);
      map.set('---', 8);
      map.set('++-', 2);
      map.set('--+', 7);
      map.set('+-+', 3);
      map.set('-+-', 6);
      map.set('+--', 4);
      map.set('-++', 5);

      for (let i = 0; i < faceGroups.length; i++) {
        const n = faceGroups[i].normal;
        const sx = n.x >= 0 ? '+' : '-';
        const sy = n.y >= 0 ? '+' : '-';
        const sz = n.z >= 0 ? '+' : '-';
        const key = sx + sy + sz;
        const val = map.get(key);
        if (!val) return null;
        v[i] = val;
      }

      return v;
    }

    function makeDie(sides, geometry, x, faceGroups, valueByFace) {
      const mesh = new THREE.Mesh(geometry, baseMat.clone());
      mesh.castShadow = true;
      mesh.receiveShadow = false;
      mesh.userData = { sides };

      // Slightly different tint per die
      const tints = {
        4: 0xe5e7eb,
        6: 0xf8fafc,
        8: 0xe2e8f0,
        10: 0xf1f5f9,
        12: 0xe7e5e4,
        20: 0xf5f5f4,
      };
      mesh.material.color.setHex(tints[sides] || 0xf3f4f6);

      // Place dice near the top of the tray.
      mesh.position.set(x, 2.2, 0);
      // Friendly isometric-ish pose.
      mesh.rotation.set(0.65, 0.55, 0.08);

      // Die-type badge above (helps selection, not the rolled value).
      geometry.computeBoundingBox();
      const bb = geometry.boundingBox;
      const topY = (bb ? bb.max.y : 1.0);
      const badge = createBadgePlane('d' + sides, 0.46);
      badge.position.set(0, topY + 0.20, 0);
      badge.rotation.x = -Math.PI / 2;
      badge.renderOrder = 11;
      mesh.add(badge);
      mesh.userData.badge = badge;

      // Add per-face numbers.
      addFaceNumberLabels(mesh, sides, faceGroups, valueByFace);

      return mesh;
    }

    const dice = [];
    const geometries = [
      [4, new THREE.TetrahedronGeometry(0.78, 0)],
      [6, new THREE.BoxGeometry(1.05, 1.05, 1.05)],
      [8, new THREE.OctahedronGeometry(0.82, 0)],
      [10, createD10Geometry(0.86)],
      [12, new THREE.DodecahedronGeometry(0.86, 0)],
      [20, new THREE.IcosahedronGeometry(0.9, 0)],
    ];

    const spacing = 1.65;
    const startX = -((geometries.length - 1) * spacing) / 2;

    for (let i = 0; i < geometries.length; i++) {
      const [sides, geo] = geometries[i];
      const x = startX + i * spacing;

      let faceGroups;
      let valueByFace;

      {
        faceGroups = computeFaceGroups(geo);
        if (sides === 4 && faceGroups.length === 4) {
          // User-requested: put 1,2,3,4 on the d4 faces.
          valueByFace = [1, 2, 3, 4];
        } else if (sides === 6 && faceGroups.length >= 6) {
          valueByFace = buildD6Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else if (sides === 8 && faceGroups.length === 8) {
          valueByFace = buildD8Values(faceGroups) || buildOppositePairingValues(faceGroups, sides);
        } else {
          valueByFace = buildOppositePairingValues(faceGroups, sides);
        }
      }

      const mesh = makeDie(sides, geo, x, faceGroups, valueByFace);
      const lines = makeEdges(mesh);
      scene.add(mesh);
      scene.add(lines);
      dice.push({ mesh, lines, sides, anim: null });
    }

    function resize() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);
    resize();

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function postDie(sides) {
      const payload = JSON.stringify({ type: 'die', sides });
      if (window.chrome && window.chrome.webview && window.chrome.webview.postMessage) {
        window.chrome.webview.postMessage(payload);
      }
    }

    canvas.addEventListener('click', (ev) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(dice.map(d => d.mesh), false);
      if (hits.length > 0) {
        const sides = hits[0].object.userData.sides;
        postDie(sides);
      }
    });

    function applyIdlePose(d) {
      d.mesh.rotation.set(0.65, 0.55, 0.08);
      d.anim = null;
    }

    const UP = new THREE.Vector3(0, 1, 0);

    function quaternionForValue(mesh, value) {
      const map = mesh.userData.valueToNormal;
      if (!map || !map.get) return null;
      const n = map.get(value);
      if (!n) return null;
      const q = new THREE.Quaternion().setFromUnitVectors(n.clone().normalize(), UP);
      const yaw = new THREE.Quaternion().setFromAxisAngle(UP, (Math.random() * Math.PI * 2));
      q.multiply(yaw);
      return q;
    }

    function kickRollToValue(d, value) {
      const target = quaternionForValue(d.mesh, value);
      const start = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random() * 2.2, Math.random() * 2.2, Math.random() * 2.2));
      d.mesh.quaternion.copy(start);

      d.anim = {
        t: 0,
        duration: 1.05,
        start,
        target: target || new THREE.Quaternion().setFromEuler(new THREE.Euler(0.65, 0.55, 0.08)),
      };
    }

    function setPreview() {
      for (const d of dice) {
        applyIdlePose(d);
      }
    }

    function showRollResults(items) {
      // items: [{sides,value}]
      const buckets = new Map();
      for (const it of items || []) {
        const s = Number(it.sides);
        let v = Number(it.value);
        if (!Number.isFinite(s) || !Number.isFinite(v)) continue;

        // d10 may come through as 0 (meaning 10) depending on upstream formatting.
        if (s === 10 && v === 0) v = 10;

        if (!buckets.has(s)) buckets.set(s, []);
        buckets.get(s).push(v);
      }

      for (const d of dice) {
        const values = buckets.get(d.sides) || [];
        if (values.length > 0) {
          const v = values.shift();
          kickRollToValue(d, v);
        } else {
          applyIdlePose(d);
        }
      }
    }

    // Messages from host (C#): {type:'preview'} or {type:'roll', dice:[{sides,value}]}
    if (window.chrome && window.chrome.webview) {
      window.chrome.webview.addEventListener('message', (ev) => {
        try {
          const msg = typeof ev.data === 'string' ? JSON.parse(ev.data) : ev.data;
          if (!msg || !msg.type) return;
          if (msg.type === 'preview') setPreview();
          if (msg.type === 'roll') showRollResults(msg.dice || []);
        } catch { }
      });
    }

    setPreview();

    let t0 = performance.now();
    function animate() {
      const t = performance.now();
      const dt = (t - t0) / 1000;
      t0 = t;

      for (const d of dice) {
        if (d.anim) {
          d.anim.t += dt;
          const u = Math.min(1, d.anim.t / d.anim.duration);
          const s = u * u * (3 - 2 * u);

          d.mesh.quaternion.slerpQuaternions(d.anim.start, d.anim.target, s);

          // mild settle wobble early
          if (u < 0.85) {
            const wob = (1 - u) * 0.08;
            d.mesh.rotateX(Math.sin(t * 0.009) * wob);
            d.mesh.rotateZ(Math.cos(t * 0.011) * wob);
          }

          if (u >= 1) {
            d.anim = null;
          }
        }

        d.lines.position.copy(d.mesh.position);
        d.lines.quaternion.copy(d.mesh.quaternion);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
